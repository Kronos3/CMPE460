
cmake-build-bcm2835/top/bcm2835/test_timer:     file format elf32-littlearm


Disassembly of section .text:

00008000 <_start>:
.equ    GIC_CPUB_offset,        0x1000

// At the start address we have a "jump table", specifically laid out to allow jump to an address that is stored in
// memory. This table must be laid out exactly as shown (including the instruction ldr pc,)
_start:
    ldr pc, _reset_h
    8000:	e59ff018 	ldr	pc, [pc, #24]	; 8020 <_reset_h>
    ldr pc, _undefined_instruction_vector_h
    8004:	e59ff018 	ldr	pc, [pc, #24]	; 8024 <_undefined_instruction_vector_h>
    ldr pc, _software_interrupt_vector_h
    8008:	e59ff018 	ldr	pc, [pc, #24]	; 8028 <_software_interrupt_vector_h>
    ldr pc, _prefetch_abort_vector_h
    800c:	e59ff018 	ldr	pc, [pc, #24]	; 802c <_prefetch_abort_vector_h>
    ldr pc, _data_abort_vector_h
    8010:	e59ff018 	ldr	pc, [pc, #24]	; 8030 <_data_abort_vector_h>
    ldr pc, _unused_handler_h
    8014:	e59ff018 	ldr	pc, [pc, #24]	; 8034 <_unused_handler_h>
    ldr pc, _interrupt_vector_h
    8018:	e59ff018 	ldr	pc, [pc, #24]	; 8038 <_interrupt_vector_h>
    ldr pc, _fast_interrupt_vector_h
    801c:	e59ff018 	ldr	pc, [pc, #24]	; 803c <_fast_interrupt_vector_h>

00008020 <_reset_h>:
    8020:	00008040 	.word	0x00008040

00008024 <_undefined_instruction_vector_h>:
    8024:	00008538 	.word	0x00008538

00008028 <_software_interrupt_vector_h>:
    8028:	0000853c 	.word	0x0000853c

0000802c <_prefetch_abort_vector_h>:
    802c:	00008540 	.word	0x00008540

00008030 <_data_abort_vector_h>:
    8030:	00008544 	.word	0x00008544

00008034 <_unused_handler_h>:
    8034:	00008040 	.word	0x00008040

00008038 <_interrupt_vector_h>:
    8038:	00008110 	.word	0x00008110

0000803c <_fast_interrupt_vector_h>:
    803c:	000085d8 	.word	0x000085d8

00008040 <_reset_>:
_reset_:
    // Determine what mode the cpu has started up in. When we get to the very start of the ARM execution we can
    // extract the Current Program Status Register value and mask off the Mode field which is defined in the ARM
    // Architecture Reference Manual for ARMV6 ARMV7 and ARMV8 as M[4:0] - in other words the 5 lowest bits
    // Do this in a high register so as not to overwrite anything the bootloader has passed over (such as atags)
    mrs r12, CPSR
    8040:	e10fc000 	mrs	ip, CPSR
    and r12, #CPSR_MODE_MASK    // Zero all bits except the CPSR_MODE_MASK bits to be left with the mode value in r11
    8044:	e20cc01f 	and	ip, ip, #31

    // Store the CPSR start mode in a "global variable" that is accessible to all (including the C world)
    ldr r11, =_cpsr_startup_mode
    8048:	e59fb0b8 	ldr	fp, [pc, #184]	; 8108 <_enable_interrupts+0x14>
    str r12, [r11]
    804c:	e58bc000 	str	ip, [fp]
    // When the ARM processor starts all four processors run the same code. 'tis weird, n'est pas?
    // In order to get some sanity back to our world we "park" the remaining cores and just work with one core. We're
    // not yet at the point of requiring parallel processing.

    // Skip the Hypervisor mode check and core parking when RPI0/1
    mrc p15, 0, r11, c0, c0, 0
    8050:	ee10bf10 	mrc	15, 0, fp, cr0, cr0, {0}
    ldr r10, =#MAINID_ARMV6
    8054:	e59fa0b0 	ldr	sl, [pc, #176]	; 810c <_enable_interrupts+0x18>
    cmp r11, r10
    8058:	e15b000a 	cmp	fp, sl
    beq _setup_interrupt_table
    805c:	0a00000b 	beq	8090 <_setup_interrupt_table>

    // Did we start up in hypervisor mode? If we didn't go ahead an park the cpus, we can then get back to SVC mode
    // later on
    cmp r12, #CPSR_MODE_HYPERVISOR
    8060:	e35c001a 	cmp	ip, #26
    bne _multicore_park
    8064:	1a000006 	bne	8084 <_multicore_park>

    // We're in hypervisor mode and we need to switch back in order to allow us to continue successfully
    mrs r12, CPSR
    8068:	e10fc000 	mrs	ip, CPSR
    bic r12, r12, #CPSR_MODE_MASK
    806c:	e3ccc01f 	bic	ip, ip, #31
    orr r12, r12, #(CPSR_MODE_SVR | CPSR_IRQ_INHIBIT | CPSR_FIQ_INHIBIT )
    8070:	e38cc0d3 	orr	ip, ip, #211	; 0xd3
    msr SPSR_cxsf, r12
    8074:	e16ff00c 	msr	SPSR_fsxc, ip

    add lr, pc, #4
    8078:	e28fe004 	add	lr, pc, #4
    807c:	e12ef30e 	.word	0xe12ef30e
    8080:	e160006e 	.word	0xe160006e

00008084 <_multicore_park>:
    .word 0xE160006E

_multicore_park:
    // On RPI2/3 make sure all cores that are not core 0 branch off to an infinite loop to make them enter a spinlock
    // We will then only operate with core 0 and setup stack pointers and the like for core 0
    mrc p15, 0, r12, c0, c0, 5
    8084:	ee10cfb0 	mrc	15, 0, ip, cr0, cr0, {5}
    ands r12, #0x3
    8088:	e21cc003 	ands	ip, ip, #3
    bne _inf_loop
    808c:	1a00000c 	bne	80c4 <_inf_loop>

00008090 <_setup_interrupt_table>:

_setup_interrupt_table:

    mov     r0, #0x8000
    8090:	e3a00902 	mov	r0, #32768	; 0x8000
    mov     r1, #0x0000
    8094:	e3a01000 	mov	r1, #0
    ldmia   r0!,{r2, r3, r4, r5, r6, r7, r8, r9}
    8098:	e8b003fc 	ldm	r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
    stmia   r1!,{r2, r3, r4, r5, r6, r7, r8, r9}
    809c:	e8a103fc 	stmia	r1!, {r2, r3, r4, r5, r6, r7, r8, r9}
    ldmia   r0!,{r2, r3, r4, r5, r6, r7, r8, r9}
    80a0:	e8b003fc 	ldm	r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
    stmia   r1!,{r2, r3, r4, r5, r6, r7, r8, r9}
    80a4:	e8a103fc 	stmia	r1!, {r2, r3, r4, r5, r6, r7, r8, r9}

    // We're going to use interrupt mode, so setup the interrupt mode
    // stack pointer which differs to the application stack pointer:
    mov r0, #(CPSR_MODE_IRQ | CPSR_IRQ_INHIBIT | CPSR_FIQ_INHIBIT )
    80a8:	e3a000d2 	mov	r0, #210	; 0xd2
    msr cpsr_c, r0
    80ac:	e121f000 	msr	CPSR_c, r0
    ldr sp, =0x7000
    80b0:	e3a0da07 	mov	sp, #28672	; 0x7000

    // Switch back to supervisor mode (our application mode) and
    // set the stack pointer. Remember that the stack works its way
    // down memory, our heap will work it's way up from after the
    // application.
    mov r0, #(CPSR_MODE_SVR | CPSR_IRQ_INHIBIT | CPSR_FIQ_INHIBIT )
    80b4:	e3a000d3 	mov	r0, #211	; 0xd3
    msr cpsr_c, r0
    80b8:	e121f000 	msr	CPSR_c, r0
    ldr sp, =0x8000
    80bc:	e3a0d902 	mov	sp, #32768	; 0x8000

    // The c-startup function which we never return from. This function will
    // initialise the ro data section (most things that have the const
    // declaration) and initialise the bss section variables to 0 (generally
    // known as automatics). It'll then call main, which should never return.
    bl _cstartup
    80c0:	eb000105 	bl	84dc <_cstartup>

000080c4 <_inf_loop>:

    // If main does return for some reason, just catch it and stay here.
_inf_loop:
    b _inf_loop
    80c4:	eafffffe 	b	80c4 <_inf_loop>

000080c8 <_cpsr_startup_mode>:
    80c8:	00000000 	.word	0x00000000

000080cc <_osc>:
    80cc:	0337f980 	.word	0x0337f980

000080d0 <_value>:
    80d0:	00063fff 	.word	0x00063fff

000080d4 <_mbox>:
    80d4:	ff8000cc 	.word	0xff8000cc

000080d8 <_enable_speedup>:
_value:              .word    0x63fff
_mbox:               .word    0xff8000cc

_enable_speedup:
    // Enable L1 cache and branch prediction
    mrc     p15, 0, r0, c1, c0, 0
    80d8:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orrs     r0, r0, #0x1800
    80dc:	e3900b06 	orrs	r0, r0, #6144	; 0x1800
    mcr     p15, 0, r0, c1, c0, 0
    80e0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    mov     pc, lr
    80e4:	e1a0f00e 	mov	pc, lr

000080e8 <_get_stack_pointer>:

_get_stack_pointer:
    // Return the stack pointer value
    str     sp, [sp]
    80e8:	e58dd000 	str	sp, [sp]
    ldr     r0, [sp]
    80ec:	e59d0000 	ldr	r0, [sp]

    // Return from the function
    mov     pc, lr
    80f0:	e1a0f00e 	mov	pc, lr

000080f4 <_enable_interrupts>:


_enable_interrupts:
    mrs     r0, cpsr
    80f4:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #CPSR_IRQ_INHIBIT
    80f8:	e3c00080 	bic	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
    80fc:	e121f000 	msr	CPSR_c, r0
    cpsie   if
    8100:	f10800c0 	cpsie	if

    mov     pc, lr
    8104:	e1a0f00e 	mov	pc, lr
    ldr r11, =_cpsr_startup_mode
    8108:	000080c8 	.word	0x000080c8
    ldr r10, =#MAINID_ARMV6
    810c:	410fb767 	.word	0x410fb767

00008110 <interrupt_vector>:
#include <drv/bcm2835/arm_timer.h>
#include <bcm2835_int.h>

void __attribute__((interrupt("IRQ")))
interrupt_vector(void)
{
    8110:	e24ee004 	sub	lr, lr, #4
    8114:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
    if (ARM_TIMER->MSK_IRQ)
    8118:	e59f3040 	ldr	r3, [pc, #64]	; 8160 <interrupt_vector+0x50>
    811c:	e5933014 	ldr	r3, [r3, #20]
    8120:	e3530000 	cmp	r3, #0
    8124:	08fd900f 	ldmeq	sp!, {r0, r1, r2, r3, ip, pc}^
    {
        static I32 i = 0;
        gpio_output(GPIO_ACT_LED, i++ % 2);
    8128:	e59f3034 	ldr	r3, [pc, #52]	; 8164 <interrupt_vector+0x54>
    812c:	e5931000 	ldr	r1, [r3]
    8130:	e2812001 	add	r2, r1, #1
    8134:	e5832000 	str	r2, [r3]
    8138:	e3510000 	cmp	r1, #0
    813c:	e2011001 	and	r1, r1, #1
    8140:	b2611000 	rsblt	r1, r1, #0
    8144:	e6ef1071 	uxtb	r1, r1
    8148:	e3a0002f 	mov	r0, #47	; 0x2f
    814c:	eb00020b 	bl	8980 <gpio_output>
//        ARM_TIMER->LOAD = ARM_TIMER->RELOAD;
        ARM_TIMER->IRQ_CLR_ACK = 0x1;
    8150:	e59f3008 	ldr	r3, [pc, #8]	; 8160 <interrupt_vector+0x50>
    8154:	e3a02001 	mov	r2, #1
    8158:	e583200c 	str	r2, [r3, #12]
    }
}
    815c:	e8fd900f 	ldm	sp!, {r0, r1, r2, r3, ip, pc}^
    8160:	7e00b400 	.word	0x7e00b400
    8164:	0001ab90 	.word	0x0001ab90

00008168 <main>:

void main(void)
{
    8168:	e92d4010 	push	{r4, lr}
    gpio_init(GPIO_ACT_LED, GPIO_FUNCTION_OUTPUT);
    816c:	e3a01001 	mov	r1, #1
    8170:	e3a0002f 	mov	r0, #47	; 0x2f
    8174:	eb0001ba 	bl	8864 <gpio_init>
    gpio_output(GPIO_ACT_LED, FALSE); // led off
    8178:	e3a01000 	mov	r1, #0
    817c:	e3a0002f 	mov	r0, #47	; 0x2f
    8180:	eb0001fe 	bl	8980 <gpio_output>

    ARM_TIMER->LOAD = 0x400;
    8184:	e59f4028 	ldr	r4, [pc, #40]	; 81b4 <main+0x4c>
    8188:	e3a03b01 	mov	r3, #1024	; 0x400
    818c:	e5843000 	str	r3, [r4]

    bcm2835_interrupt_register(BCM2835_IRQ_ID_TIMER_0, NULL);
    8190:	e3a01000 	mov	r1, #0
    8194:	e3a00040 	mov	r0, #64	; 0x40
    8198:	eb000070 	bl	8360 <bcm2835_interrupt_register>
    bcm2835_interrupt_enable(BCM2835_IRQ_ID_TIMER_0);
    819c:	e3a00040 	mov	r0, #64	; 0x40
    81a0:	eb00007f 	bl	83a4 <bcm2835_interrupt_enable>

    ARM_TIMER->CTRL =
    81a4:	e3a030aa 	mov	r3, #170	; 0xaa
    81a8:	e5843008 	str	r3, [r4, #8]

    // Run a 2 Hz clock signal
//    tim_init(TIM_0, tim_handler, 0.01);
//    tim_start(TIM_0);

    ENABLE_INTERRUPTS();
    81ac:	ebffffd0 	bl	80f4 <_enable_interrupts>
}
    81b0:	e8bd8010 	pop	{r4, pc}
    81b4:	7e00b400 	.word	0x7e00b400

000081b8 <nop_handler>:
#include <stdarg.h>
#include <fw.h>
#include <instr.h>

I32 nop_handler(const char* fmt, ...)
{
    81b8:	e92d000f 	push	{r0, r1, r2, r3}
    (void) nop_handler;
    (void) fmt;
    return 0;
}
    81bc:	e3a00000 	mov	r0, #0
    81c0:	e28dd010 	add	sp, sp, #16
    81c4:	e12fff1e 	bx	lr

000081c8 <fw_assertion_failure>:
#endif

void fw_assertion_failure(const char* file, U32 line,
                          const char* expr_str,
                          U32 nargs, ...)
{
    81c8:	e52d3004 	push	{r3}		; (str r3, [sp, #-4]!)
    81cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    81d0:	e24dd008 	sub	sp, sp, #8
    81d4:	e1a03002 	mov	r3, r2
    81d8:	e59d500c 	ldr	r5, [sp, #12]
    // Mask all interrupts
    // Assertion reached, nothing else should run
    DISABLE_INTERRUPTS();
    81dc:	f10c00c0 	cpsid	if

    uprintf("Assertion failed %s:%u : (%s)",
    81e0:	e1a02001 	mov	r2, r1
    81e4:	e1a01000 	mov	r1, r0
    81e8:	e59f004c 	ldr	r0, [pc, #76]	; 823c <fw_assertion_failure+0x74>
    81ec:	ebfffff1 	bl	81b8 <nop_handler>
            file, line, expr_str);

    va_list args;
    va_start(args, nargs);
    81f0:	e28d3010 	add	r3, sp, #16
    81f4:	e58d3004 	str	r3, [sp, #4]
    for (U32 i = 0; i < nargs; i++)
    81f8:	e3550000 	cmp	r5, #0
    81fc:	0a00000a 	beq	822c <fw_assertion_failure+0x64>
    8200:	e3a04000 	mov	r4, #0
    {
        uprintf(", %d", va_arg(args, int));
    8204:	e59f6034 	ldr	r6, [pc, #52]	; 8240 <fw_assertion_failure+0x78>
    8208:	e59d3004 	ldr	r3, [sp, #4]
    820c:	e2832004 	add	r2, r3, #4
    8210:	e58d2004 	str	r2, [sp, #4]
    8214:	e5931000 	ldr	r1, [r3]
    8218:	e1a00006 	mov	r0, r6
    821c:	ebffffe5 	bl	81b8 <nop_handler>
    for (U32 i = 0; i < nargs; i++)
    8220:	e2844001 	add	r4, r4, #1
    8224:	e1550004 	cmp	r5, r4
    8228:	1afffff6 	bne	8208 <fw_assertion_failure+0x40>
    }
    va_end(args);
    uprintf("\r\n");
    822c:	e59f0010 	ldr	r0, [pc, #16]	; 8244 <fw_assertion_failure+0x7c>
    8230:	ebffffe0 	bl	81b8 <nop_handler>

    // Hang Mr. CPU please
//    BREAKPOINT(); // break point if we are in a debugger
    while (1)
    {
        WAIT_FOR_INTERRUPT();
    8234:	e320f003 	wfi
    while (1)
    8238:	eafffffd 	b	8234 <fw_assertion_failure+0x6c>
    823c:	0000a960 	.word	0x0000a960
    8240:	0000a980 	.word	0x0000a980
    8244:	0000a988 	.word	0x0000a988

00008248 <interrupt_vector_>:
    }
}

void __attribute__((interrupt("IRQ")))
interrupt_vector_(void)
{
    8248:	e24ee004 	sub	lr, lr, #4
    824c:	e92d53ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, lr}
    register U32 ul_masked_status = INTCREGS->IRQ_Basic;
    8250:	e59f3100 	ldr	r3, [pc, #256]	; 8358 <interrupt_vector_+0x110>
    8254:	e5935000 	ldr	r5, [r3]

    // Bit 8 in IRQBasic indicates interrupts in Pending1 (interrupts 31-0):
    if (ul_masked_status & (1UL << 8))
    8258:	e3150c01 	tst	r5, #256	; 0x100
    825c:	1a00000b 	bne	8290 <interrupt_vector_+0x48>
    {
        irq_handler_range(INTCREGS->Pending1 & enabled_interrupts[0], 0);
    }

    // Bit 9 in IRQBasic indicates interrupts in Pending2 (interrupts 63-32):
    if (ul_masked_status & (1UL << 9))
    8260:	e3150c02 	tst	r5, #512	; 0x200
    8264:	1a00001c 	bne	82dc <interrupt_vector_+0x94>
    {
        irq_handler_range(INTCREGS->Pending2 & enabled_interrupts[1], 32);
    }

    // Bits 7 through 0 in IRQBasic represent interrupts 64-71:
    if (ul_masked_status & 0xFF)
    8268:	e31500ff 	tst	r5, #255	; 0xff
    826c:	08fd93ff 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
    {
        irq_handler_range(ul_masked_status & 0xFF & enabled_interrupts[2], 64);
    8270:	e59f30e4 	ldr	r3, [pc, #228]	; 835c <interrupt_vector_+0x114>
    8274:	e5933008 	ldr	r3, [r3, #8]
    8278:	e0054003 	and	r4, r5, r3
    while (pending)
    827c:	e21440ff 	ands	r4, r4, #255	; 0xff
    8280:	08fd93ff 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
        if (vector_table[irq])
    8284:	e59f70d0 	ldr	r7, [pc, #208]	; 835c <interrupt_vector_+0x114>
        pending &= ~(1UL << bit);
    8288:	e3a06001 	mov	r6, #1
    828c:	ea000029 	b	8338 <interrupt_vector_+0xf0>
        irq_handler_range(INTCREGS->Pending1 & enabled_interrupts[0], 0);
    8290:	e5936004 	ldr	r6, [r3, #4]
    8294:	e59f30c0 	ldr	r3, [pc, #192]	; 835c <interrupt_vector_+0x114>
    8298:	e5933000 	ldr	r3, [r3]
    while (pending)
    829c:	e0166003 	ands	r6, r6, r3
    82a0:	0affffee 	beq	8260 <interrupt_vector_+0x18>
        if (vector_table[irq])
    82a4:	e59f80b0 	ldr	r8, [pc, #176]	; 835c <interrupt_vector_+0x114>
        pending &= ~(1UL << bit);
    82a8:	e3a07001 	mov	r7, #1
    82ac:	ea000001 	b	82b8 <interrupt_vector_+0x70>
    while (pending)
    82b0:	e1d66417 	bics	r6, r6, r7, lsl r4
    82b4:	0affffe9 	beq	8260 <interrupt_vector_+0x18>
        U32 bit = 31 - __builtin_clz(pending);
    82b8:	e16f4f16 	clz	r4, r6
    82bc:	e264401f 	rsb	r4, r4, #31
        if (vector_table[irq])
    82c0:	e0883104 	add	r3, r8, r4, lsl #2
    82c4:	e593300c 	ldr	r3, [r3, #12]
    82c8:	e3530000 	cmp	r3, #0
    82cc:	0afffff7 	beq	82b0 <interrupt_vector_+0x68>
            vector_table[irq](irq);
    82d0:	e1a00004 	mov	r0, r4
    82d4:	e12fff33 	blx	r3
    82d8:	eafffff4 	b	82b0 <interrupt_vector_+0x68>
        irq_handler_range(INTCREGS->Pending2 & enabled_interrupts[1], 32);
    82dc:	e59f3074 	ldr	r3, [pc, #116]	; 8358 <interrupt_vector_+0x110>
    82e0:	e5934008 	ldr	r4, [r3, #8]
    82e4:	e59f3070 	ldr	r3, [pc, #112]	; 835c <interrupt_vector_+0x114>
    82e8:	e5933004 	ldr	r3, [r3, #4]
    while (pending)
    82ec:	e0144003 	ands	r4, r4, r3
    82f0:	0affffdc 	beq	8268 <interrupt_vector_+0x20>
        if (vector_table[irq])
    82f4:	e59f8060 	ldr	r8, [pc, #96]	; 835c <interrupt_vector_+0x114>
        pending &= ~(1UL << bit);
    82f8:	e3a07001 	mov	r7, #1
    82fc:	ea000001 	b	8308 <interrupt_vector_+0xc0>
    while (pending)
    8300:	e1d44617 	bics	r4, r4, r7, lsl r6
    8304:	0affffd7 	beq	8268 <interrupt_vector_+0x20>
        U32 bit = 31 - __builtin_clz(pending);
    8308:	e16f0f14 	clz	r0, r4
    830c:	e260601f 	rsb	r6, r0, #31
        U32 irq = base + bit;
    8310:	e260003f 	rsb	r0, r0, #63	; 0x3f
        if (vector_table[irq])
    8314:	e0883100 	add	r3, r8, r0, lsl #2
    8318:	e593300c 	ldr	r3, [r3, #12]
    831c:	e3530000 	cmp	r3, #0
    8320:	0afffff6 	beq	8300 <interrupt_vector_+0xb8>
            vector_table[irq](irq);
    8324:	e12fff33 	blx	r3
    8328:	eafffff4 	b	8300 <interrupt_vector_+0xb8>
    832c:	e12fff33 	blx	r3
    while (pending)
    8330:	e1d44516 	bics	r4, r4, r6, lsl r5
    8334:	08fd93ff 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
        U32 bit = 31 - __builtin_clz(pending);
    8338:	e16f0f14 	clz	r0, r4
    833c:	e260501f 	rsb	r5, r0, #31
        U32 irq = base + bit;
    8340:	e260005f 	rsb	r0, r0, #95	; 0x5f
        if (vector_table[irq])
    8344:	e0873100 	add	r3, r7, r0, lsl #2
    8348:	e593300c 	ldr	r3, [r3, #12]
    834c:	e3530000 	cmp	r3, #0
    8350:	1afffff5 	bne	832c <interrupt_vector_+0xe4>
    8354:	eafffff5 	b	8330 <interrupt_vector_+0xe8>
    8358:	2000b200 	.word	0x2000b200
    835c:	0001ab94 	.word	0x0001ab94

00008360 <bcm2835_interrupt_register>:
#endif

void bcm2835_interrupt_register(bcm2835_Interrupt irq,
                                bcm2835_InterruptHandler handler)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    8360:	e3500047 	cmp	r0, #71	; 0x47
    8364:	8a000003 	bhi	8378 <bcm2835_interrupt_register+0x18>
    vector_table[irq] = handler;
    8368:	e59f3028 	ldr	r3, [pc, #40]	; 8398 <bcm2835_interrupt_register+0x38>
    836c:	e0833100 	add	r3, r3, r0, lsl #2
    8370:	e583100c 	str	r1, [r3, #12]
    8374:	e12fff1e 	bx	lr
{
    8378:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    837c:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    8380:	e58d0000 	str	r0, [sp]
    8384:	e3a03001 	mov	r3, #1
    8388:	e59f200c 	ldr	r2, [pc, #12]	; 839c <bcm2835_interrupt_register+0x3c>
    838c:	e3a01051 	mov	r1, #81	; 0x51
    8390:	e59f0008 	ldr	r0, [pc, #8]	; 83a0 <bcm2835_interrupt_register+0x40>
    8394:	ebffff8b 	bl	81c8 <fw_assertion_failure>
    8398:	0001ab94 	.word	0x0001ab94
    839c:	0000a98c 	.word	0x0000a98c
    83a0:	0000a9ac 	.word	0x0000a9ac

000083a4 <bcm2835_interrupt_enable>:
}

void bcm2835_interrupt_enable(bcm2835_Interrupt irq)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    83a4:	e3500047 	cmp	r0, #71	; 0x47
    83a8:	8a00000b 	bhi	83dc <bcm2835_interrupt_enable+0x38>
    U32 mask = 1UL << (irq % 32);
    83ac:	e200201f 	and	r2, r0, #31
    83b0:	e3a03001 	mov	r3, #1
    83b4:	e1a03213 	lsl	r3, r3, r2

    if (irq <= 31)
    83b8:	e350001f 	cmp	r0, #31
    83bc:	8a00000e 	bhi	83fc <bcm2835_interrupt_enable+0x58>
    {
        INTCREGS->Enable1 = mask;
    83c0:	e59f2068 	ldr	r2, [pc, #104]	; 8430 <bcm2835_interrupt_enable+0x8c>
    83c4:	e5823010 	str	r3, [r2, #16]
        enabled_interrupts[0] |= mask;
    83c8:	e59f1064 	ldr	r1, [pc, #100]	; 8434 <bcm2835_interrupt_enable+0x90>
    83cc:	e5912000 	ldr	r2, [r1]
    83d0:	e1823003 	orr	r3, r2, r3
    83d4:	e5813000 	str	r3, [r1]
    83d8:	e12fff1e 	bx	lr
{
    83dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    83e0:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    83e4:	e58d0000 	str	r0, [sp]
    83e8:	e3a03001 	mov	r3, #1
    83ec:	e59f2044 	ldr	r2, [pc, #68]	; 8438 <bcm2835_interrupt_enable+0x94>
    83f0:	e3a01057 	mov	r1, #87	; 0x57
    83f4:	e59f0040 	ldr	r0, [pc, #64]	; 843c <bcm2835_interrupt_enable+0x98>
    83f8:	ebffff72 	bl	81c8 <fw_assertion_failure>
    }
    else if (irq <= 63)
    83fc:	e350003f 	cmp	r0, #63	; 0x3f
    {
        INTCREGS->Enable2 = mask;
    8400:	e59f2028 	ldr	r2, [pc, #40]	; 8430 <bcm2835_interrupt_enable+0x8c>
    8404:	95823014 	strls	r3, [r2, #20]
        enabled_interrupts[1] |= mask;
    8408:	959f1024 	ldrls	r1, [pc, #36]	; 8434 <bcm2835_interrupt_enable+0x90>
    840c:	95912004 	ldrls	r2, [r1, #4]
    8410:	91823003 	orrls	r3, r2, r3
    8414:	95813004 	strls	r3, [r1, #4]
    }
    else if (irq < BCM2835_INTC_TOTAL_IRQ)
    {
        INTCREGS->EnableBasic = mask;
    8418:	85823018 	strhi	r3, [r2, #24]
        enabled_interrupts[2] |= mask;
    841c:	859f1010 	ldrhi	r1, [pc, #16]	; 8434 <bcm2835_interrupt_enable+0x90>
    8420:	85912008 	ldrhi	r2, [r1, #8]
    8424:	81823003 	orrhi	r3, r2, r3
    8428:	85813008 	strhi	r3, [r1, #8]
    842c:	e12fff1e 	bx	lr
    8430:	2000b200 	.word	0x2000b200
    8434:	0001ab94 	.word	0x0001ab94
    8438:	0000a98c 	.word	0x0000a98c
    843c:	0000a9ac 	.word	0x0000a9ac

00008440 <bcm2835_interrupt_disable>:
    }
}

void bcm2835_interrupt_disable(bcm2835_Interrupt irq)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    8440:	e3500047 	cmp	r0, #71	; 0x47
    8444:	8a00000b 	bhi	8478 <bcm2835_interrupt_disable+0x38>
    U32 mask = 1UL << (irq % 32);
    8448:	e200201f 	and	r2, r0, #31
    844c:	e3a03001 	mov	r3, #1
    8450:	e1a03213 	lsl	r3, r3, r2

    if (irq <= 31)
    8454:	e350001f 	cmp	r0, #31
    8458:	8a00000e 	bhi	8498 <bcm2835_interrupt_disable+0x58>
    {
        INTCREGS->Disable1 = mask;
    845c:	e59f2068 	ldr	r2, [pc, #104]	; 84cc <bcm2835_interrupt_disable+0x8c>
    8460:	e582301c 	str	r3, [r2, #28]
        enabled_interrupts[0] &= ~mask;
    8464:	e59f1064 	ldr	r1, [pc, #100]	; 84d0 <bcm2835_interrupt_disable+0x90>
    8468:	e5912000 	ldr	r2, [r1]
    846c:	e1c23003 	bic	r3, r2, r3
    8470:	e5813000 	str	r3, [r1]
    8474:	e12fff1e 	bx	lr
{
    8478:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    847c:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
    8480:	e58d0000 	str	r0, [sp]
    8484:	e3a03001 	mov	r3, #1
    8488:	e59f2044 	ldr	r2, [pc, #68]	; 84d4 <bcm2835_interrupt_disable+0x94>
    848c:	e3a0106d 	mov	r1, #109	; 0x6d
    8490:	e59f0040 	ldr	r0, [pc, #64]	; 84d8 <bcm2835_interrupt_disable+0x98>
    8494:	ebffff4b 	bl	81c8 <fw_assertion_failure>
    }
    else if (irq <= 63)
    8498:	e350003f 	cmp	r0, #63	; 0x3f
    {
        INTCREGS->Disable2 = mask;
    849c:	e59f2028 	ldr	r2, [pc, #40]	; 84cc <bcm2835_interrupt_disable+0x8c>
    84a0:	95823020 	strls	r3, [r2, #32]
        enabled_interrupts[1] &= ~mask;
    84a4:	959f1024 	ldrls	r1, [pc, #36]	; 84d0 <bcm2835_interrupt_disable+0x90>
    84a8:	95912004 	ldrls	r2, [r1, #4]
    84ac:	91c23003 	bicls	r3, r2, r3
    84b0:	95813004 	strls	r3, [r1, #4]
    }
    else if (irq < BCM2835_INTC_TOTAL_IRQ)
    {
        INTCREGS->DisableBasic = mask;
    84b4:	85823024 	strhi	r3, [r2, #36]	; 0x24
        enabled_interrupts[2] &= ~mask;
    84b8:	859f1010 	ldrhi	r1, [pc, #16]	; 84d0 <bcm2835_interrupt_disable+0x90>
    84bc:	85912008 	ldrhi	r2, [r1, #8]
    84c0:	81c23003 	bichi	r3, r2, r3
    84c4:	85813008 	strhi	r3, [r1, #8]
    84c8:	e12fff1e 	bx	lr
    84cc:	2000b200 	.word	0x2000b200
    84d0:	0001ab94 	.word	0x0001ab94
    84d4:	0000a98c 	.word	0x0000a98c
    84d8:	0000a9ac 	.word	0x0000a9ac

000084dc <_cstartup>:
extern int __bss_start__;
extern int __bss_end__;
extern void _cstartup(void);
extern void _enable_speedup(void);
void _cstartup(void)
{
    84dc:	e92d4010 	push	{r4, lr}
    // Enables L1 cache and branch prediction
    _enable_speedup();
    84e0:	ebfffefc 	bl	80d8 <_enable_speedup>

    int* bss = &__bss_start__;
    int* bss_end = &__bss_end__;

    while( bss < bss_end )
    84e4:	e59f203c 	ldr	r2, [pc, #60]	; 8528 <_cstartup+0x4c>
    84e8:	e59f303c 	ldr	r3, [pc, #60]	; 852c <_cstartup+0x50>
    84ec:	e1520003 	cmp	r2, r3
    84f0:	2a000009 	bcs	851c <_cstartup+0x40>
    84f4:	e1a03002 	mov	r3, r2
    84f8:	e59f2030 	ldr	r2, [pc, #48]	; 8530 <_cstartup+0x54>
    84fc:	e0422003 	sub	r2, r2, r3
    8500:	e3c22003 	bic	r2, r2, #3
    8504:	e2822004 	add	r2, r2, #4
    8508:	e0822003 	add	r2, r2, r3
        *bss++ = 0;
    850c:	e3a01000 	mov	r1, #0
    8510:	e4831004 	str	r1, [r3], #4
    while( bss < bss_end )
    8514:	e1530002 	cmp	r3, r2
    8518:	1afffffc 	bne	8510 <_cstartup+0x34>

    main();
    851c:	ebffff11 	bl	8168 <main>

    // Main has exited
    // Trap the CPU
    while(1)
    {
        WAIT_FOR_INTERRUPT();
    8520:	e320f003 	wfi
    while(1)
    8524:	eafffffd 	b	8520 <_cstartup+0x44>
    8528:	0001ab90 	.word	0x0001ab90
    852c:	0001ad2c 	.word	0x0001ad2c
    8530:	0001ad2b 	.word	0x0001ad2b

00008534 <reset_vector>:
    the ARM is handed control at the end of boot loading
*/
void __attribute__((interrupt("ABORT"))) reset_vector(void)
{

}
    8534:	e25ef004 	subs	pc, lr, #4

00008538 <undefined_instruction_vector>:
    If an undefined intstruction is encountered, the CPU will start
    executing this function. Just trap here as a debug solution.
*/
void __attribute__((interrupt("UNDEF"))) undefined_instruction_vector(void)
{
    while (1)
    8538:	eafffffe 	b	8538 <undefined_instruction_vector>

0000853c <software_interrupt_vector>:
    The CPU will start executing this function. Just trap here as a debug
    solution.
*/
void __attribute__((interrupt("SWI"))) software_interrupt_vector(void)
{
    while (1)
    853c:	eafffffe 	b	853c <software_interrupt_vector>

00008540 <prefetch_abort_vector>:
    The CPU will start executing this function. Just trap here as a debug
    solution.
*/
void __attribute__((interrupt("ABORT"))) prefetch_abort_vector(void)
{
}
    8540:	e25ef004 	subs	pc, lr, #4

00008544 <data_abort_vector>:
    solution.
*/
void __attribute__((interrupt("ABORT"))) data_abort_vector(void)
{

}
    8544:	e25ef004 	subs	pc, lr, #4

00008548 <arm_timer_interrupt_irq>:
);

static bool_t global_initialized = FALSE;

static void arm_timer_interrupt_irq(U32 irq)
{
    8548:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    (void) irq;
    for (U32 i = 0; i < TIM_N; i++)
    854c:	e59f407c 	ldr	r4, [pc, #124]	; 85d0 <arm_timer_interrupt_irq+0x88>
    8550:	e3a05000 	mov	r5, #0
    {
        if (virtual_timer.timers[i].configured &&
            virtual_timer.timers[i].running)
        {
            if (!--virtual_timer.timers[i].value)
    8554:	e1a07004 	mov	r7, r4
    8558:	ea000006 	b	8578 <arm_timer_interrupt_irq+0x30>
                if (virtual_timer.timers[i].task)
                {
                    virtual_timer.timers[i].task();
                }

                virtual_timer.timers[i].value = virtual_timer.timers[i].reload;
    855c:	e5962008 	ldr	r2, [r6, #8]
    8560:	e0873205 	add	r3, r7, r5, lsl #4
    8564:	e5832004 	str	r2, [r3, #4]
    for (U32 i = 0; i < TIM_N; i++)
    8568:	e2855001 	add	r5, r5, #1
    856c:	e2844010 	add	r4, r4, #16
    8570:	e3550006 	cmp	r5, #6
    8574:	0a000011 	beq	85c0 <arm_timer_interrupt_irq+0x78>
        if (virtual_timer.timers[i].configured &&
    8578:	e1a06004 	mov	r6, r4
    857c:	e5d43011 	ldrb	r3, [r4, #17]
    8580:	e3530000 	cmp	r3, #0
    8584:	0afffff7 	beq	8568 <arm_timer_interrupt_irq+0x20>
    8588:	e5d43010 	ldrb	r3, [r4, #16]
    858c:	e3530000 	cmp	r3, #0
    8590:	0afffff4 	beq	8568 <arm_timer_interrupt_irq+0x20>
            if (!--virtual_timer.timers[i].value)
    8594:	e0872205 	add	r2, r7, r5, lsl #4
    8598:	e5923004 	ldr	r3, [r2, #4]
    859c:	e2433001 	sub	r3, r3, #1
    85a0:	e5823004 	str	r3, [r2, #4]
    85a4:	e3530000 	cmp	r3, #0
    85a8:	1affffee 	bne	8568 <arm_timer_interrupt_irq+0x20>
                if (virtual_timer.timers[i].task)
    85ac:	e594300c 	ldr	r3, [r4, #12]
    85b0:	e3530000 	cmp	r3, #0
    85b4:	0affffe8 	beq	855c <arm_timer_interrupt_irq+0x14>
                    virtual_timer.timers[i].task();
    85b8:	e12fff33 	blx	r3
    85bc:	eaffffe6 	b	855c <arm_timer_interrupt_irq+0x14>
            }
        }
    }

    // Clear the interrupt
    ARM_TIMER->IRQ_CLR_ACK = 0x1;
    85c0:	e59f300c 	ldr	r3, [pc, #12]	; 85d4 <arm_timer_interrupt_irq+0x8c>
    85c4:	e3a02001 	mov	r2, #1
    85c8:	e583200c 	str	r2, [r3, #12]
}
    85cc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    85d0:	0001acc0 	.word	0x0001acc0
    85d4:	7e00b400 	.word	0x7e00b400

000085d8 <fast_interrupt_vector>:

void __attribute__((interrupt("FIQ")))
fast_interrupt_vector(void)
{
}
    85d8:	e25ef004 	subs	pc, lr, #4

000085dc <tim_init>:
    bcm2835_interrupt_register(BCM2835_IRQ_ID_TIMER_0, arm_timer_interrupt_irq);
    bcm2835_interrupt_enable(BCM2835_IRQ_ID_TIMER_0);
}

void tim_init(tim_t timer, void (*task)(void), F64 hz)
{
    85dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    85e0:	e24dd008 	sub	sp, sp, #8
    85e4:	e1a05000 	mov	r5, r0
    85e8:	e1a08001 	mov	r8, r1
    85ec:	e1a06002 	mov	r6, r2
    85f0:	e1a07003 	mov	r7, r3
    if (global_initialized)
    85f4:	e59f30f0 	ldr	r3, [pc, #240]	; 86ec <tim_init+0x110>
    85f8:	e5d33064 	ldrb	r3, [r3, #100]	; 0x64
    85fc:	e3530000 	cmp	r3, #0
    8600:	0a00001a 	beq	8670 <tim_init+0x94>
    global_init();

    FW_ASSERT(timer < TIM_N, timer);
    8604:	e3550005 	cmp	r5, #5
    8608:	8a000027 	bhi	86ac <tim_init+0xd0>
    FW_ASSERT(task);
    860c:	e3580000 	cmp	r8, #0
    8610:	0a00002b 	beq	86c4 <tim_init+0xe8>

    FW_ASSERT(hz < BCM2835_TIMER_BASE_FREQ && "Requested frequency too high"
    8614:	e3a02000 	mov	r2, #0
    8618:	e59f30d0 	ldr	r3, [pc, #208]	; 86f0 <tim_init+0x114>
    861c:	e1a00006 	mov	r0, r6
    8620:	e1a01007 	mov	r1, r7
    8624:	eb000720 	bl	a2ac <__aeabi_dcmplt>
    8628:	e3500000 	cmp	r0, #0
    862c:	0a000029 	beq	86d8 <tim_init+0xfc>
                                              "try raising BCM2835_TIMER_BASE_FREQ");

    VirtualTimer* self = &virtual_timer.timers[timer];
    self->reload = BCM2835_TIMER_BASE_FREQ / hz;
    8630:	e59f40b4 	ldr	r4, [pc, #180]	; 86ec <tim_init+0x110>
    8634:	e0844205 	add	r4, r4, r5, lsl #4
    8638:	e1a02006 	mov	r2, r6
    863c:	e1a03007 	mov	r3, r7
    8640:	e3a00000 	mov	r0, #0
    8644:	e59f10a4 	ldr	r1, [pc, #164]	; 86f0 <tim_init+0x114>
    8648:	eb00065b 	bl	9fbc <__aeabi_ddiv>
    864c:	eb00072e 	bl	a30c <__aeabi_d2uiz>
    8650:	e5840008 	str	r0, [r4, #8]
    self->task = task;
    8654:	e584800c 	str	r8, [r4, #12]
    self->configured = TRUE;
    8658:	e3a03001 	mov	r3, #1
    865c:	e5c43011 	strb	r3, [r4, #17]
    self->running = FALSE;
    8660:	e3a03000 	mov	r3, #0
    8664:	e5c43010 	strb	r3, [r4, #16]
}
    8668:	e28dd008 	add	sp, sp, #8
    866c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ARM_TIMER->LOAD = reload;
    8670:	e59f307c 	ldr	r3, [pc, #124]	; 86f4 <tim_init+0x118>
    8674:	e59f207c 	ldr	r2, [pc, #124]	; 86f8 <tim_init+0x11c>
    8678:	e5832000 	str	r2, [r3]
    ARM_TIMER->RELOAD = reload;
    867c:	e5832018 	str	r2, [r3, #24]
    ARM_TIMER->CTRL =
    8680:	e3a02022 	mov	r2, #34	; 0x22
    8684:	e5832008 	str	r2, [r3, #8]
    global_initialized = TRUE;
    8688:	e59f305c 	ldr	r3, [pc, #92]	; 86ec <tim_init+0x110>
    868c:	e3a02001 	mov	r2, #1
    8690:	e5c32064 	strb	r2, [r3, #100]	; 0x64
    bcm2835_interrupt_register(BCM2835_IRQ_ID_TIMER_0, arm_timer_interrupt_irq);
    8694:	e59f1060 	ldr	r1, [pc, #96]	; 86fc <tim_init+0x120>
    8698:	e3a00040 	mov	r0, #64	; 0x40
    869c:	ebffff2f 	bl	8360 <bcm2835_interrupt_register>
    bcm2835_interrupt_enable(BCM2835_IRQ_ID_TIMER_0);
    86a0:	e3a00040 	mov	r0, #64	; 0x40
    86a4:	ebffff3e 	bl	83a4 <bcm2835_interrupt_enable>
    86a8:	eaffffd5 	b	8604 <tim_init+0x28>
    FW_ASSERT(timer < TIM_N, timer);
    86ac:	e58d5000 	str	r5, [sp]
    86b0:	e3a03001 	mov	r3, #1
    86b4:	e59f2044 	ldr	r2, [pc, #68]	; 8700 <tim_init+0x124>
    86b8:	e3a01056 	mov	r1, #86	; 0x56
    86bc:	e59f0040 	ldr	r0, [pc, #64]	; 8704 <tim_init+0x128>
    86c0:	ebfffec0 	bl	81c8 <fw_assertion_failure>
    FW_ASSERT(task);
    86c4:	e3a03000 	mov	r3, #0
    86c8:	e59f2038 	ldr	r2, [pc, #56]	; 8708 <tim_init+0x12c>
    86cc:	e3a01057 	mov	r1, #87	; 0x57
    86d0:	e59f002c 	ldr	r0, [pc, #44]	; 8704 <tim_init+0x128>
    86d4:	ebfffebb 	bl	81c8 <fw_assertion_failure>
    FW_ASSERT(hz < BCM2835_TIMER_BASE_FREQ && "Requested frequency too high"
    86d8:	e3a03000 	mov	r3, #0
    86dc:	e59f2028 	ldr	r2, [pc, #40]	; 870c <tim_init+0x130>
    86e0:	e3a01059 	mov	r1, #89	; 0x59
    86e4:	e59f0018 	ldr	r0, [pc, #24]	; 8704 <tim_init+0x128>
    86e8:	ebfffeb6 	bl	81c8 <fw_assertion_failure>
    86ec:	0001acc0 	.word	0x0001acc0
    86f0:	408f4000 	.word	0x408f4000
    86f4:	7e00b400 	.word	0x7e00b400
    86f8:	000f4240 	.word	0x000f4240
    86fc:	00008548 	.word	0x00008548
    8700:	0000a9e8 	.word	0x0000a9e8
    8704:	0000a9f8 	.word	0x0000a9f8
    8708:	0000aa24 	.word	0x0000aa24
    870c:	0000aa2c 	.word	0x0000aa2c

00008710 <tim_start>:

void tim_start(tim_t timer)
{
    8710:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8714:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(timer < TIM_N, timer);
    8718:	e3500005 	cmp	r0, #5
    871c:	8a000017 	bhi	8780 <tim_start+0x70>
    FW_ASSERT(virtual_timer.timers[timer].configured && "Timer not initialized",
    8720:	e59f3088 	ldr	r3, [pc, #136]	; 87b0 <tim_start+0xa0>
    8724:	e0833200 	add	r3, r3, r0, lsl #4
    8728:	e5d33011 	ldrb	r3, [r3, #17]
    872c:	e3530000 	cmp	r3, #0
    8730:	0a000018 	beq	8798 <tim_start+0x88>
              timer);

    virtual_timer.timers[timer].value = virtual_timer.timers[timer].reload;
    8734:	e59f3074 	ldr	r3, [pc, #116]	; 87b0 <tim_start+0xa0>
    8738:	e0830200 	add	r0, r3, r0, lsl #4
    873c:	e5902008 	ldr	r2, [r0, #8]
    8740:	e5802004 	str	r2, [r0, #4]
    virtual_timer.timers[timer].running = TRUE;
    8744:	e3a02001 	mov	r2, #1
    8748:	e5c02010 	strb	r2, [r0, #16]

    if (virtual_timer.running_n++ == 0)
    874c:	e5932000 	ldr	r2, [r3]
    8750:	e2821001 	add	r1, r2, #1
    8754:	e5831000 	str	r1, [r3]
    8758:	e3520000 	cmp	r2, #0
    875c:	1a000005 	bne	8778 <tim_start+0x68>
    {
        // No timers are running yet meaning
        // the physical timer should be started

        // Reset the counter
        ARM_TIMER->LOAD = ARM_TIMER->RELOAD;
    8760:	e59f304c 	ldr	r3, [pc, #76]	; 87b4 <tim_start+0xa4>
    8764:	e5932018 	ldr	r2, [r3, #24]
    8768:	e5832000 	str	r2, [r3]

        // Enable the timer
        ARM_TIMER->CTRL |= ARM_TIMER_CTRL_EN;
    876c:	e5932008 	ldr	r2, [r3, #8]
    8770:	e3822080 	orr	r2, r2, #128	; 0x80
    8774:	e5832008 	str	r2, [r3, #8]
    }
}
    8778:	e28dd00c 	add	sp, sp, #12
    877c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    FW_ASSERT(timer < TIM_N, timer);
    8780:	e58d0000 	str	r0, [sp]
    8784:	e3a03001 	mov	r3, #1
    8788:	e59f2028 	ldr	r2, [pc, #40]	; 87b8 <tim_start+0xa8>
    878c:	e3a01065 	mov	r1, #101	; 0x65
    8790:	e59f0024 	ldr	r0, [pc, #36]	; 87bc <tim_start+0xac>
    8794:	ebfffe8b 	bl	81c8 <fw_assertion_failure>
    FW_ASSERT(virtual_timer.timers[timer].configured && "Timer not initialized",
    8798:	e58d0000 	str	r0, [sp]
    879c:	e3a03001 	mov	r3, #1
    87a0:	e59f2018 	ldr	r2, [pc, #24]	; 87c0 <tim_start+0xb0>
    87a4:	e3a01066 	mov	r1, #102	; 0x66
    87a8:	e59f000c 	ldr	r0, [pc, #12]	; 87bc <tim_start+0xac>
    87ac:	ebfffe85 	bl	81c8 <fw_assertion_failure>
    87b0:	0001acc0 	.word	0x0001acc0
    87b4:	7e00b400 	.word	0x7e00b400
    87b8:	0000a9e8 	.word	0x0000a9e8
    87bc:	0000a9f8 	.word	0x0000a9f8
    87c0:	0000aa94 	.word	0x0000aa94

000087c4 <tim_stop>:

void tim_stop(tim_t timer)
{
    87c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    87c8:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(timer < TIM_N, timer);
    87cc:	e3500005 	cmp	r0, #5
    87d0:	8a000012 	bhi	8820 <tim_stop+0x5c>
    FW_ASSERT(virtual_timer.timers[timer].configured && "Timer not initialized",
    87d4:	e59f3074 	ldr	r3, [pc, #116]	; 8850 <tim_stop+0x8c>
    87d8:	e0833200 	add	r3, r3, r0, lsl #4
    87dc:	e5d33011 	ldrb	r3, [r3, #17]
    87e0:	e3530000 	cmp	r3, #0
    87e4:	0a000013 	beq	8838 <tim_stop+0x74>
              timer);

    virtual_timer.timers[timer].running = FALSE;
    87e8:	e59f2060 	ldr	r2, [pc, #96]	; 8850 <tim_stop+0x8c>
    87ec:	e0820200 	add	r0, r2, r0, lsl #4
    87f0:	e3a03000 	mov	r3, #0
    87f4:	e5c03010 	strb	r3, [r0, #16]

    if (--virtual_timer.running_n == 0)
    87f8:	e5923000 	ldr	r3, [r2]
    87fc:	e2433001 	sub	r3, r3, #1
    8800:	e5823000 	str	r3, [r2]
    8804:	e3530000 	cmp	r3, #0
    {
        // All virtual timers have stopped
        // We can stop the physical timer
        ARM_TIMER->CTRL &= ~ARM_TIMER_CTRL_EN;
    8808:	059f2044 	ldreq	r2, [pc, #68]	; 8854 <tim_stop+0x90>
    880c:	05923008 	ldreq	r3, [r2, #8]
    8810:	03c33080 	biceq	r3, r3, #128	; 0x80
    8814:	05823008 	streq	r3, [r2, #8]
    }
}
    8818:	e28dd00c 	add	sp, sp, #12
    881c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    FW_ASSERT(timer < TIM_N, timer);
    8820:	e58d0000 	str	r0, [sp]
    8824:	e3a03001 	mov	r3, #1
    8828:	e59f2028 	ldr	r2, [pc, #40]	; 8858 <tim_stop+0x94>
    882c:	e3a0107b 	mov	r1, #123	; 0x7b
    8830:	e59f0024 	ldr	r0, [pc, #36]	; 885c <tim_stop+0x98>
    8834:	ebfffe63 	bl	81c8 <fw_assertion_failure>
    FW_ASSERT(virtual_timer.timers[timer].configured && "Timer not initialized",
    8838:	e58d0000 	str	r0, [sp]
    883c:	e3a03001 	mov	r3, #1
    8840:	e59f2018 	ldr	r2, [pc, #24]	; 8860 <tim_stop+0x9c>
    8844:	e3a0107c 	mov	r1, #124	; 0x7c
    8848:	e59f000c 	ldr	r0, [pc, #12]	; 885c <tim_stop+0x98>
    884c:	ebfffe5d 	bl	81c8 <fw_assertion_failure>
    8850:	0001acc0 	.word	0x0001acc0
    8854:	7e00b400 	.word	0x7e00b400
    8858:	0000a9e8 	.word	0x0000a9e8
    885c:	0000a9f8 	.word	0x0000a9f8
    8860:	0000aa94 	.word	0x0000aa94

00008864 <gpio_init>:
#include <drv/gpio.h>
#include <drv/bcm2835/bcm2835.h>

void gpio_init(GpioPin pin, gpio_function_t function)
{
    8864:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8868:	e24dd00c 	sub	sp, sp, #12
    switch (function)
    886c:	e3510007 	cmp	r1, #7
    8870:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    8874:	ea000020 	b	88fc <gpio_init+0x98>
    8878:	00008898 	.word	0x00008898
    887c:	000088a8 	.word	0x000088a8
    8880:	000088b4 	.word	0x000088b4
    8884:	000088c0 	.word	0x000088c0
    8888:	000088cc 	.word	0x000088cc
    888c:	000088d8 	.word	0x000088d8
    8890:	000088e4 	.word	0x000088e4
    8894:	000088f0 	.word	0x000088f0
    {
        case GPIO_FUNCTION_INPUT:
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_INPT);
    8898:	e3a01000 	mov	r1, #0
    889c:	eb000040 	bl	89a4 <bcm2835_gpio_fsel>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT5);
            break;
        default:
            FW_ASSERT(0 && "Invalid function select", function);
    }
}
    88a0:	e28dd00c 	add	sp, sp, #12
    88a4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_OUTP);
    88a8:	e3a01001 	mov	r1, #1
    88ac:	eb00003c 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88b0:	eafffffa 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT0);
    88b4:	e3a01004 	mov	r1, #4
    88b8:	eb000039 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88bc:	eafffff7 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT1);
    88c0:	e3a01005 	mov	r1, #5
    88c4:	eb000036 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88c8:	eafffff4 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT2);
    88cc:	e3a01006 	mov	r1, #6
    88d0:	eb000033 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88d4:	eafffff1 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT3);
    88d8:	e3a01007 	mov	r1, #7
    88dc:	eb000030 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88e0:	eaffffee 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT4);
    88e4:	e3a01003 	mov	r1, #3
    88e8:	eb00002d 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88ec:	eaffffeb 	b	88a0 <gpio_init+0x3c>
            bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_ALT5);
    88f0:	e3a01002 	mov	r1, #2
    88f4:	eb00002a 	bl	89a4 <bcm2835_gpio_fsel>
            break;
    88f8:	eaffffe8 	b	88a0 <gpio_init+0x3c>
    switch (function)
    88fc:	e58d1000 	str	r1, [sp]
            FW_ASSERT(0 && "Invalid function select", function);
    8900:	e3a03001 	mov	r3, #1
    8904:	e59f2008 	ldr	r2, [pc, #8]	; 8914 <gpio_init+0xb0>
    8908:	e3a01021 	mov	r1, #33	; 0x21
    890c:	e59f0004 	ldr	r0, [pc, #4]	; 8918 <gpio_init+0xb4>
    8910:	ebfffe2c 	bl	81c8 <fw_assertion_failure>
    8914:	0000aad8 	.word	0x0000aad8
    8918:	0000aaf8 	.word	0x0000aaf8

0000891c <gpio_options>:

void gpio_options(GpioPin pin, gpio_options_t options)
{
    891c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8920:	e24dd00c 	sub	sp, sp, #12
    switch(options)
    8924:	e3510001 	cmp	r1, #1
    8928:	0a00000c 	beq	8960 <gpio_options+0x44>
    892c:	e3510002 	cmp	r1, #2
    8930:	0a00000d 	beq	896c <gpio_options+0x50>
    8934:	e3510000 	cmp	r1, #0
    8938:	0a000005 	beq	8954 <gpio_options+0x38>
    893c:	e58d1000 	str	r1, [sp]
            break;
        case GPIO_OPTIONS_PUD_UP:
            bcm2835_gpio_set_pud(pin, BCM2835_GPIO_PUD_UP);
            break;
        default:
            FW_ASSERT(0 && "Invalid options select", options);
    8940:	e3a03001 	mov	r3, #1
    8944:	e59f202c 	ldr	r2, [pc, #44]	; 8978 <gpio_options+0x5c>
    8948:	e3a01033 	mov	r1, #51	; 0x33
    894c:	e59f0028 	ldr	r0, [pc, #40]	; 897c <gpio_options+0x60>
    8950:	ebfffe1c 	bl	81c8 <fw_assertion_failure>
            bcm2835_gpio_set_pud(pin, BCM2835_GPIO_PUD_OFF);
    8954:	eb000125 	bl	8df0 <bcm2835_gpio_set_pud>
    }
}
    8958:	e28dd00c 	add	sp, sp, #12
    895c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
            bcm2835_gpio_set_pud(pin, BCM2835_GPIO_PUD_DOWN);
    8960:	e3a01001 	mov	r1, #1
    8964:	eb000121 	bl	8df0 <bcm2835_gpio_set_pud>
            break;
    8968:	eafffffa 	b	8958 <gpio_options+0x3c>
            bcm2835_gpio_set_pud(pin, BCM2835_GPIO_PUD_UP);
    896c:	e3a01002 	mov	r1, #2
    8970:	eb00011e 	bl	8df0 <bcm2835_gpio_set_pud>
            break;
    8974:	eafffff7 	b	8958 <gpio_options+0x3c>
    8978:	0000ab24 	.word	0x0000ab24
    897c:	0000aaf8 	.word	0x0000aaf8

00008980 <gpio_output>:

void gpio_output(GpioPin pin, bool_t output)
{
    8980:	e92d4010 	push	{r4, lr}
    switch(output)
    8984:	e3510000 	cmp	r1, #0
    8988:	1a000001 	bne	8994 <gpio_output+0x14>
    {
        case FALSE:
            bcm2835_gpio_clr(pin);
    898c:	eb00003b 	bl	8a80 <bcm2835_gpio_clr>
            break;
    8990:	e8bd8010 	pop	{r4, pc}
        case TRUE:
        default:
            bcm2835_gpio_set(pin);
    8994:	eb000022 	bl	8a24 <bcm2835_gpio_set>
            break;
    }
}
    8998:	e8bd8010 	pop	{r4, pc}

0000899c <bcm2835_peri_write_nb>:
}

// write to peripheral without the write barrier
void bcm2835_peri_write_nb(volatile U32* paddr, U32 value)
{
    *paddr = value;
    899c:	e5801000 	str	r1, [r0]
}
    89a0:	e12fff1e 	bx	lr

000089a4 <bcm2835_gpio_fsel>:
// So the 3 bits for port X are:
//      X / 10 + ((X % 10) * 3)
COMPILE_ASSERT(&BCM2835_GPIO->FSEL[4] == (U32*)0x20200010, fsel_4_location);
void bcm2835_gpio_fsel(U8 pin, U8 mode)
{
    FW_ASSERT(pin / 10 < 6, pin);
    89a4:	e350003b 	cmp	r0, #59	; 0x3b
    89a8:	8a000012 	bhi	89f8 <bcm2835_gpio_fsel+0x54>

    // Function selects are 10 pins per 32 bit word, 3 bits per pin
    volatile U32* paddr = &BCM2835_GPIO->FSEL[pin / 10];
    89ac:	e59f3064 	ldr	r3, [pc, #100]	; 8a18 <bcm2835_gpio_fsel+0x74>
    89b0:	e0832093 	umull	r2, r3, r3, r0
    89b4:	e1a021a3 	lsr	r2, r3, #3
    89b8:	e1a03102 	lsl	r3, r2, #2
    89bc:	e2833202 	add	r3, r3, #536870912	; 0x20000000
    89c0:	e2833602 	add	r3, r3, #2097152	; 0x200000

    U8 shift = (pin % 10) * 3;
    89c4:	e0822102 	add	r2, r2, r2, lsl #2
    89c8:	e0400082 	sub	r0, r0, r2, lsl #1
    89cc:	e0800080 	add	r0, r0, r0, lsl #1
    U32 mask = BCM2835_GPIO_FSEL_MASK << shift;
    89d0:	e6ef0070 	uxtb	r0, r0
    U32 ret = *paddr;
    89d4:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    89d8:	e593c000 	ldr	ip, [r3]
    v = (v & ~mask) | (value & mask);
    89dc:	e0221011 	eor	r1, r2, r1, lsl r0
    89e0:	e3a0c007 	mov	ip, #7
    89e4:	e001101c 	and	r1, r1, ip, lsl r0
    89e8:	e0211002 	eor	r1, r1, r2
    *paddr = value;
    89ec:	e5831000 	str	r1, [r3]
    *paddr = value;
    89f0:	e5831000 	str	r1, [r3]
    89f4:	e12fff1e 	bx	lr
{
    89f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    89fc:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(pin / 10 < 6, pin);
    8a00:	e58d0000 	str	r0, [sp]
    8a04:	e3a03001 	mov	r3, #1
    8a08:	e59f200c 	ldr	r2, [pc, #12]	; 8a1c <bcm2835_gpio_fsel+0x78>
    8a0c:	e3a01061 	mov	r1, #97	; 0x61
    8a10:	e59f0008 	ldr	r0, [pc, #8]	; 8a20 <bcm2835_gpio_fsel+0x7c>
    8a14:	ebfffdeb 	bl	81c8 <fw_assertion_failure>
    8a18:	cccccccd 	.word	0xcccccccd
    8a1c:	0000ab44 	.word	0x0000ab44
    8a20:	0000ab54 	.word	0x0000ab54

00008a24 <bcm2835_gpio_set>:

// Set output pin
COMPILE_ASSERT(&BCM2835_GPIO->SET[1] == (U32*)0x20200020, gpio_set_check);
void bcm2835_gpio_set(U8 pin)
{
    FW_ASSERT(pin < 64, pin);
    8a24:	e350003f 	cmp	r0, #63	; 0x3f
    8a28:	8a000009 	bhi	8a54 <bcm2835_gpio_set+0x30>
    volatile U32* paddr = &BCM2835_GPIO->SET[pin / 32];
    8a2c:	e1a022a0 	lsr	r2, r0, #5
    8a30:	e59f303c 	ldr	r3, [pc, #60]	; 8a74 <bcm2835_gpio_set+0x50>
    U32 ret = *paddr;
    8a34:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8a38:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = bcm2835_peri_read(paddr);
    bcm2835_peri_write(paddr, value | (1 << shift));
    8a3c:	e200001f 	and	r0, r0, #31
    8a40:	e3a0c001 	mov	ip, #1
    8a44:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8a48:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8a4c:	e7831102 	str	r1, [r3, r2, lsl #2]
    8a50:	e12fff1e 	bx	lr
{
    8a54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8a58:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(pin < 64, pin);
    8a5c:	e58d0000 	str	r0, [sp]
    8a60:	e3a03001 	mov	r3, #1
    8a64:	e59f200c 	ldr	r2, [pc, #12]	; 8a78 <bcm2835_gpio_set+0x54>
    8a68:	e3a01070 	mov	r1, #112	; 0x70
    8a6c:	e59f0008 	ldr	r0, [pc, #8]	; 8a7c <bcm2835_gpio_set+0x58>
    8a70:	ebfffdd4 	bl	81c8 <fw_assertion_failure>
    8a74:	2020001c 	.word	0x2020001c
    8a78:	0000ab84 	.word	0x0000ab84
    8a7c:	0000ab54 	.word	0x0000ab54

00008a80 <bcm2835_gpio_clr>:
}

// Clear output pin
void bcm2835_gpio_clr(U8 pin)
{
    FW_ASSERT(pin < 64, pin);
    8a80:	e350003f 	cmp	r0, #63	; 0x3f
    8a84:	8a000009 	bhi	8ab0 <bcm2835_gpio_clr+0x30>
    volatile U32* paddr = &BCM2835_GPIO->CLR[pin / 32];
    8a88:	e1a022a0 	lsr	r2, r0, #5
    8a8c:	e59f303c 	ldr	r3, [pc, #60]	; 8ad0 <bcm2835_gpio_clr+0x50>
    U32 ret = *paddr;
    8a90:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8a94:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = bcm2835_peri_read(paddr);
    bcm2835_peri_write(paddr, value | (1 << shift));
    8a98:	e200001f 	and	r0, r0, #31
    8a9c:	e3a0c001 	mov	ip, #1
    8aa0:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8aa4:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8aa8:	e7831102 	str	r1, [r3, r2, lsl #2]
    8aac:	e12fff1e 	bx	lr
{
    8ab0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8ab4:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(pin < 64, pin);
    8ab8:	e58d0000 	str	r0, [sp]
    8abc:	e3a03001 	mov	r3, #1
    8ac0:	e59f200c 	ldr	r2, [pc, #12]	; 8ad4 <bcm2835_gpio_clr+0x54>
    8ac4:	e3a0107a 	mov	r1, #122	; 0x7a
    8ac8:	e59f0008 	ldr	r0, [pc, #8]	; 8ad8 <bcm2835_gpio_clr+0x58>
    8acc:	ebfffdbd 	bl	81c8 <fw_assertion_failure>
    8ad0:	20200028 	.word	0x20200028
    8ad4:	0000ab84 	.word	0x0000ab84
    8ad8:	0000ab54 	.word	0x0000ab54

00008adc <bcm2835_gpio_lev>:
}

// Read input pin
U8 bcm2835_gpio_lev(U8 pin)
{
    volatile U32* paddr = &BCM2835_GPIO->LEV[pin / 32];
    8adc:	e1a012a0 	lsr	r1, r0, #5
    8ae0:	e59f201c 	ldr	r2, [pc, #28]	; 8b04 <bcm2835_gpio_lev+0x28>
    U32 ret = *paddr;
    8ae4:	e7923101 	ldr	r3, [r2, r1, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8ae8:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    U8 shift = pin % 32;
    U32 value = bcm2835_peri_read(paddr);
    return (value & (1 << shift)) ? HIGH : LOW;
    8aec:	e200001f 	and	r0, r0, #31
    8af0:	e3a02001 	mov	r2, #1
    8af4:	e0133012 	ands	r3, r3, r2, lsl r0
}
    8af8:	11a00002 	movne	r0, r2
    8afc:	03a00000 	moveq	r0, #0
    8b00:	e12fff1e 	bx	lr
    8b04:	20200034 	.word	0x20200034

00008b08 <bcm2835_gpio_eds>:

// See if an event detection bit is set
// Sigh cant support interrupts yet
U8 bcm2835_gpio_eds(U8 pin)
{
    volatile U32* paddr = &BCM2835_GPIO->EDS[pin / 32];
    8b08:	e1a012a0 	lsr	r1, r0, #5
    8b0c:	e59f201c 	ldr	r2, [pc, #28]	; 8b30 <bcm2835_gpio_eds+0x28>
    U32 ret = *paddr;
    8b10:	e7923101 	ldr	r3, [r2, r1, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8b14:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    U8 shift = pin % 32;
    U32 value = bcm2835_peri_read(paddr);
    return (value & (1 << shift)) ? HIGH : LOW;
    8b18:	e200001f 	and	r0, r0, #31
    8b1c:	e3a02001 	mov	r2, #1
    8b20:	e0133012 	ands	r3, r3, r2, lsl r0
}
    8b24:	11a00002 	movne	r0, r2
    8b28:	03a00000 	moveq	r0, #0
    8b2c:	e12fff1e 	bx	lr
    8b30:	20200040 	.word	0x20200040

00008b34 <bcm2835_gpio_set_eds>:

// Write a 1 to clear the bit in EDS
void bcm2835_gpio_set_eds(U8 pin)
{
    volatile U32* paddr = &BCM2835_GPIO->EDS[pin / 32];
    8b34:	e1a012a0 	lsr	r1, r0, #5
    8b38:	e59f2014 	ldr	r2, [pc, #20]	; 8b54 <bcm2835_gpio_set_eds+0x20>
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8b3c:	e200001f 	and	r0, r0, #31
    8b40:	e3a03001 	mov	r3, #1
    8b44:	e1a03013 	lsl	r3, r3, r0
    *paddr = value;
    8b48:	e7823101 	str	r3, [r2, r1, lsl #2]
    *paddr = value;
    8b4c:	e7823101 	str	r3, [r2, r1, lsl #2]
    bcm2835_peri_write(paddr, value);
}
    8b50:	e12fff1e 	bx	lr
    8b54:	20200040 	.word	0x20200040

00008b58 <bcm2835_gpio_ren>:

// Rising edge detect enable
void bcm2835_gpio_ren(U8 pin)
{
    volatile U32* paddr = &BCM2835_GPIO->REN[pin / 32];
    8b58:	e1a022a0 	lsr	r2, r0, #5
    8b5c:	e59f301c 	ldr	r3, [pc, #28]	; 8b80 <bcm2835_gpio_ren+0x28>
    U32 ret = *paddr;
    8b60:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8b64:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8b68:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8b6c:	e3a0c001 	mov	ip, #1
    8b70:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8b74:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8b78:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8b7c:	e12fff1e 	bx	lr
    8b80:	2020004c 	.word	0x2020004c

00008b84 <bcm2835_gpio_clr_ren>:

void bcm2835_gpio_clr_ren(U8 pin)
{
    volatile U32* paddr = &BCM2835_GPIO->REN[pin / 32];
    8b84:	e1a022a0 	lsr	r2, r0, #5
    8b88:	e59f301c 	ldr	r3, [pc, #28]	; 8bac <bcm2835_gpio_clr_ren+0x28>
    U32 ret = *paddr;
    8b8c:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8b90:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8b94:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8b98:	e3a0c001 	mov	ip, #1
    8b9c:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8ba0:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8ba4:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8ba8:	e12fff1e 	bx	lr
    8bac:	2020004c 	.word	0x2020004c

00008bb0 <bcm2835_gpio_fen>:

// Falling edge detect enable
void bcm2835_gpio_fen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPFEN0 / 4 + pin / 32;
    8bb0:	e1a022a0 	lsr	r2, r0, #5
    8bb4:	e59f301c 	ldr	r3, [pc, #28]	; 8bd8 <bcm2835_gpio_fen+0x28>
    U32 ret = *paddr;
    8bb8:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8bbc:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8bc0:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8bc4:	e3a0c001 	mov	ip, #1
    8bc8:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8bcc:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8bd0:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8bd4:	e12fff1e 	bx	lr
    8bd8:	20200058 	.word	0x20200058

00008bdc <bcm2835_gpio_clr_fen>:

void bcm2835_gpio_clr_fen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPFEN0 / 4 + pin / 32;
    8bdc:	e1a022a0 	lsr	r2, r0, #5
    8be0:	e59f301c 	ldr	r3, [pc, #28]	; 8c04 <bcm2835_gpio_clr_fen+0x28>
    U32 ret = *paddr;
    8be4:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8be8:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8bec:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8bf0:	e3a0c001 	mov	ip, #1
    8bf4:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8bf8:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8bfc:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8c00:	e12fff1e 	bx	lr
    8c04:	20200058 	.word	0x20200058

00008c08 <bcm2835_gpio_hen>:

// High detect enable
void bcm2835_gpio_hen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPHEN0 / 4 + pin / 32;
    8c08:	e1a022a0 	lsr	r2, r0, #5
    8c0c:	e59f301c 	ldr	r3, [pc, #28]	; 8c30 <bcm2835_gpio_hen+0x28>
    U32 ret = *paddr;
    8c10:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8c14:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8c18:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8c1c:	e3a0c001 	mov	ip, #1
    8c20:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8c24:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8c28:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8c2c:	e12fff1e 	bx	lr
    8c30:	20200064 	.word	0x20200064

00008c34 <bcm2835_gpio_clr_hen>:

void bcm2835_gpio_clr_hen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPHEN0 / 4 + pin / 32;
    8c34:	e1a022a0 	lsr	r2, r0, #5
    8c38:	e59f301c 	ldr	r3, [pc, #28]	; 8c5c <bcm2835_gpio_clr_hen+0x28>
    U32 ret = *paddr;
    8c3c:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8c40:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8c44:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8c48:	e3a0c001 	mov	ip, #1
    8c4c:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8c50:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8c54:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8c58:	e12fff1e 	bx	lr
    8c5c:	20200064 	.word	0x20200064

00008c60 <bcm2835_gpio_len>:

// Low detect enable
void bcm2835_gpio_len(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPLEN0 / 4 + pin / 32;
    8c60:	e1a022a0 	lsr	r2, r0, #5
    8c64:	e59f301c 	ldr	r3, [pc, #28]	; 8c88 <bcm2835_gpio_len+0x28>
    U32 ret = *paddr;
    8c68:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8c6c:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8c70:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8c74:	e3a0c001 	mov	ip, #1
    8c78:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8c7c:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8c80:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8c84:	e12fff1e 	bx	lr
    8c88:	20200070 	.word	0x20200070

00008c8c <bcm2835_gpio_clr_len>:

void bcm2835_gpio_clr_len(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPLEN0 / 4 + pin / 32;
    8c8c:	e1a022a0 	lsr	r2, r0, #5
    8c90:	e59f301c 	ldr	r3, [pc, #28]	; 8cb4 <bcm2835_gpio_clr_len+0x28>
    U32 ret = *paddr;
    8c94:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8c98:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8c9c:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8ca0:	e3a0c001 	mov	ip, #1
    8ca4:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8ca8:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8cac:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8cb0:	e12fff1e 	bx	lr
    8cb4:	20200070 	.word	0x20200070

00008cb8 <bcm2835_gpio_aren>:

// Async rising edge detect enable
void bcm2835_gpio_aren(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPAREN0 / 4 + pin / 32;
    8cb8:	e1a022a0 	lsr	r2, r0, #5
    8cbc:	e59f301c 	ldr	r3, [pc, #28]	; 8ce0 <bcm2835_gpio_aren+0x28>
    U32 ret = *paddr;
    8cc0:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8cc4:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8cc8:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8ccc:	e3a0c001 	mov	ip, #1
    8cd0:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8cd4:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8cd8:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8cdc:	e12fff1e 	bx	lr
    8ce0:	2020007c 	.word	0x2020007c

00008ce4 <bcm2835_gpio_clr_aren>:

void bcm2835_gpio_clr_aren(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPAREN0 / 4 + pin / 32;
    8ce4:	e1a022a0 	lsr	r2, r0, #5
    8ce8:	e59f301c 	ldr	r3, [pc, #28]	; 8d0c <bcm2835_gpio_clr_aren+0x28>
    U32 ret = *paddr;
    8cec:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8cf0:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8cf4:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8cf8:	e3a0c001 	mov	ip, #1
    8cfc:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8d00:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8d04:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8d08:	e12fff1e 	bx	lr
    8d0c:	2020007c 	.word	0x2020007c

00008d10 <bcm2835_gpio_afen>:

// Async falling edge detect enable
void bcm2835_gpio_afen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPAFEN0 / 4 + pin / 32;
    8d10:	e1a022a0 	lsr	r2, r0, #5
    8d14:	e59f301c 	ldr	r3, [pc, #28]	; 8d38 <bcm2835_gpio_afen+0x28>
    U32 ret = *paddr;
    8d18:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8d1c:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8d20:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8d24:	e3a0c001 	mov	ip, #1
    8d28:	e181101c 	orr	r1, r1, ip, lsl r0
    *paddr = value;
    8d2c:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8d30:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, value, value);
}
    8d34:	e12fff1e 	bx	lr
    8d38:	20200088 	.word	0x20200088

00008d3c <bcm2835_gpio_clr_afen>:

void bcm2835_gpio_clr_afen(U8 pin)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPAFEN0 / 4 + pin / 32;
    8d3c:	e1a022a0 	lsr	r2, r0, #5
    8d40:	e59f301c 	ldr	r3, [pc, #28]	; 8d64 <bcm2835_gpio_clr_afen+0x28>
    U32 ret = *paddr;
    8d44:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    *paddr; // Read without assigning to an unused variable
    8d48:	e793c102 	ldr	ip, [r3, r2, lsl #2]
    U8 shift = pin % 32;
    U32 value = 1 << shift;
    8d4c:	e200001f 	and	r0, r0, #31
    v = (v & ~mask) | (value & mask);
    8d50:	e3a0c001 	mov	ip, #1
    8d54:	e1c1101c 	bic	r1, r1, ip, lsl r0
    *paddr = value;
    8d58:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8d5c:	e7831102 	str	r1, [r3, r2, lsl #2]
    bcm2835_peri_set_bits(paddr, 0, value);
}
    8d60:	e12fff1e 	bx	lr
    8d64:	20200088 	.word	0x20200088

00008d68 <bcm2835_gpio_pud>:
    *paddr = value;
    8d68:	e59f3008 	ldr	r3, [pc, #8]	; 8d78 <bcm2835_gpio_pud+0x10>
    8d6c:	e5830094 	str	r0, [r3, #148]	; 0x94
    *paddr = value;
    8d70:	e5830094 	str	r0, [r3, #148]	; 0x94
// Set pullup/down
void bcm2835_gpio_pud(U8 pud)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPPUD / 4;
    bcm2835_peri_write(paddr, pud);
}
    8d74:	e12fff1e 	bx	lr
    8d78:	20200000 	.word	0x20200000

00008d7c <bcm2835_gpio_pudclk>:

// Pullup/down clock
// Clocks the value of pud into the GPIO pin
void bcm2835_gpio_pudclk(U8 pin, U8 on)
{
    volatile U32* paddr = ((U32*) BCM2835_GPIO_BASE) + BCM2835_GPPUDCLK0 / 4 + pin / 32;
    8d7c:	e1a022a0 	lsr	r2, r0, #5
    8d80:	e59f3018 	ldr	r3, [pc, #24]	; 8da0 <bcm2835_gpio_pudclk+0x24>
    U8 shift = pin % 32;
    bcm2835_peri_write(paddr, (on ? 1 : 0) << shift);
    8d84:	e2511000 	subs	r1, r1, #0
    8d88:	13a01001 	movne	r1, #1
    8d8c:	e200001f 	and	r0, r0, #31
    8d90:	e1a01011 	lsl	r1, r1, r0
    *paddr = value;
    8d94:	e7831102 	str	r1, [r3, r2, lsl #2]
    *paddr = value;
    8d98:	e7831102 	str	r1, [r3, r2, lsl #2]
}
    8d9c:	e12fff1e 	bx	lr
    8da0:	20200098 	.word	0x20200098

00008da4 <bcm2835_gpio_pad>:

// Read GPIO pad behaviour for groups of GPIOs
U32 bcm2835_gpio_pad(U8 group)
{
    8da4:	e1a03000 	mov	r3, r0
    volatile U32* paddr = ((U32*)BCM2835_GPIO_PADS) + BCM2835_PADS_GPIO_0_27 / 4 + group * 2;
    8da8:	e59f2008 	ldr	r2, [pc, #8]	; 8db8 <bcm2835_gpio_pad+0x14>
    U32 ret = *paddr;
    8dac:	e7920180 	ldr	r0, [r2, r0, lsl #3]
    *paddr; // Read without assigning to an unused variable
    8db0:	e7923183 	ldr	r3, [r2, r3, lsl #3]
    return bcm2835_peri_read(paddr);
}
    8db4:	e12fff1e 	bx	lr
    8db8:	2010002c 	.word	0x2010002c

00008dbc <bcm2835_gpio_set_pad>:
// Set GPIO pad behaviour for groups of GPIOs
// powerup value for al pads is
// BCM2835_PAD_SLEW_RATE_UNLIMITED | BCM2835_PAD_HYSTERESIS_ENABLED | BCM2835_PAD_DRIVE_8mA
void bcm2835_gpio_set_pad(U8 group, U32 control)
{
    volatile U32* paddr = ((U32*)BCM2835_GPIO_PADS) + BCM2835_PADS_GPIO_0_27 / 4 + group * 2;
    8dbc:	e59f300c 	ldr	r3, [pc, #12]	; 8dd0 <bcm2835_gpio_set_pad+0x14>
    bcm2835_peri_write(paddr, control | BCM2835_PAD_PASSWRD);
    8dc0:	e381145a 	orr	r1, r1, #1509949440	; 0x5a000000
    *paddr = value;
    8dc4:	e7831180 	str	r1, [r3, r0, lsl #3]
    *paddr = value;
    8dc8:	e7831180 	str	r1, [r3, r0, lsl #3]
}
    8dcc:	e12fff1e 	bx	lr
    8dd0:	2010002c 	.word	0x2010002c

00008dd4 <bcm2835_gpio_write>:
// Higher level convenience functions
//

// Set the state of an output
void bcm2835_gpio_write(U8 pin, U8 on)
{
    8dd4:	e92d4010 	push	{r4, lr}
    if (on)
    8dd8:	e3510000 	cmp	r1, #0
    8ddc:	0a000001 	beq	8de8 <bcm2835_gpio_write+0x14>
        bcm2835_gpio_set(pin);
    8de0:	ebffff0f 	bl	8a24 <bcm2835_gpio_set>
    8de4:	e8bd8010 	pop	{r4, pc}
    else
        bcm2835_gpio_clr(pin);
    8de8:	ebffff24 	bl	8a80 <bcm2835_gpio_clr>
}
    8dec:	e8bd8010 	pop	{r4, pc}

00008df0 <bcm2835_gpio_set_pud>:
// 5. Write to GPPUD to remove the control signal
// 6. Write to GPPUDCLK0/1 to remove the clock
//
// RPi has P1-03 and P1-05 with 1k8 pullup resistor
void bcm2835_gpio_set_pud(U8 pin, U8 pud)
{
    8df0:	e92d4010 	push	{r4, lr}
    8df4:	e24dd008 	sub	sp, sp, #8
    8df8:	e1a04000 	mov	r4, r0
    *paddr = value;
    8dfc:	e59f3088 	ldr	r3, [pc, #136]	; 8e8c <bcm2835_gpio_set_pud+0x9c>
    8e00:	e5831094 	str	r1, [r3, #148]	; 0x94
    *paddr = value;
    8e04:	e5831094 	str	r1, [r3, #148]	; 0x94
    bcm2835_gpio_pud(pud);
    for (volatile U32 i = -1; i > 0; i--); // delay
    8e08:	e3e03000 	mvn	r3, #0
    8e0c:	e58d3000 	str	r3, [sp]
    8e10:	e59d3000 	ldr	r3, [sp]
    8e14:	e3530000 	cmp	r3, #0
    8e18:	0a000005 	beq	8e34 <bcm2835_gpio_set_pud+0x44>
    8e1c:	e59d3000 	ldr	r3, [sp]
    8e20:	e2433001 	sub	r3, r3, #1
    8e24:	e58d3000 	str	r3, [sp]
    8e28:	e59d3000 	ldr	r3, [sp]
    8e2c:	e3530000 	cmp	r3, #0
    8e30:	1afffff9 	bne	8e1c <bcm2835_gpio_set_pud+0x2c>
    bcm2835_gpio_pudclk(pin, 1);
    8e34:	e3a01001 	mov	r1, #1
    8e38:	e1a00004 	mov	r0, r4
    8e3c:	ebffffce 	bl	8d7c <bcm2835_gpio_pudclk>
    for (volatile U32 i = -1; i > 0; i--); // delay
    8e40:	e3e03000 	mvn	r3, #0
    8e44:	e58d3004 	str	r3, [sp, #4]
    8e48:	e59d3004 	ldr	r3, [sp, #4]
    8e4c:	e3530000 	cmp	r3, #0
    8e50:	0a000005 	beq	8e6c <bcm2835_gpio_set_pud+0x7c>
    8e54:	e59d3004 	ldr	r3, [sp, #4]
    8e58:	e2433001 	sub	r3, r3, #1
    8e5c:	e58d3004 	str	r3, [sp, #4]
    8e60:	e59d3004 	ldr	r3, [sp, #4]
    8e64:	e3530000 	cmp	r3, #0
    8e68:	1afffff9 	bne	8e54 <bcm2835_gpio_set_pud+0x64>
    *paddr = value;
    8e6c:	e59f3018 	ldr	r3, [pc, #24]	; 8e8c <bcm2835_gpio_set_pud+0x9c>
    8e70:	e3a01000 	mov	r1, #0
    8e74:	e5831094 	str	r1, [r3, #148]	; 0x94
    *paddr = value;
    8e78:	e5831094 	str	r1, [r3, #148]	; 0x94
    bcm2835_gpio_pud(BCM2835_GPIO_PUD_OFF);
    bcm2835_gpio_pudclk(pin, 0);
    8e7c:	e1a00004 	mov	r0, r4
    8e80:	ebffffbd 	bl	8d7c <bcm2835_gpio_pudclk>
}
    8e84:	e28dd008 	add	sp, sp, #8
    8e88:	e8bd8010 	pop	{r4, pc}
    8e8c:	20200000 	.word	0x20200000

00008e90 <bcm2835_spi_begin>:

void bcm2835_spi_begin(void)
{
    8e90:	e92d4010 	push	{r4, lr}
    // Set the SPI0 pins to the Alt 0 function to enable SPI0 access on them
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_26, BCM2835_GPIO_FSEL_ALT0); // CE1
    8e94:	e3a01004 	mov	r1, #4
    8e98:	e3a00007 	mov	r0, #7
    8e9c:	ebfffec0 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_24, BCM2835_GPIO_FSEL_ALT0); // CE0
    8ea0:	e3a01004 	mov	r1, #4
    8ea4:	e3a00008 	mov	r0, #8
    8ea8:	ebfffebd 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_21, BCM2835_GPIO_FSEL_ALT0); // MISO
    8eac:	e3a01004 	mov	r1, #4
    8eb0:	e3a00009 	mov	r0, #9
    8eb4:	ebfffeba 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_19, BCM2835_GPIO_FSEL_ALT0); // MOSI
    8eb8:	e3a01004 	mov	r1, #4
    8ebc:	e3a0000a 	mov	r0, #10
    8ec0:	ebfffeb7 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_23, BCM2835_GPIO_FSEL_ALT0); // CLK
    8ec4:	e3a01004 	mov	r1, #4
    8ec8:	e3a0000b 	mov	r0, #11
    8ecc:	ebfffeb4 	bl	89a4 <bcm2835_gpio_fsel>
    *paddr = value;
    8ed0:	e59f3014 	ldr	r3, [pc, #20]	; 8eec <bcm2835_spi_begin+0x5c>
    8ed4:	e3a02000 	mov	r2, #0
    8ed8:	e5832000 	str	r2, [r3]
    *paddr = value;
    8edc:	e5832000 	str	r2, [r3]
    *paddr = value;
    8ee0:	e3a02030 	mov	r2, #48	; 0x30
    8ee4:	e5832000 	str	r2, [r3]
    volatile U32* paddr = ((U32*)BCM2835_SPI0_BASE) + BCM2835_SPI0_CS / 4;
    bcm2835_peri_write(paddr, 0); // All 0s

    // Clear TX and RX fifos
    bcm2835_peri_write_nb(paddr, BCM2835_SPI0_CS_CLEAR);
}
    8ee8:	e8bd8010 	pop	{r4, pc}
    8eec:	20204000 	.word	0x20204000

00008ef0 <bcm2835_spi_end>:

void bcm2835_spi_end(void)
{
    8ef0:	e92d4010 	push	{r4, lr}
    // Set all the SPI0 pins back to input
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_26, BCM2835_GPIO_FSEL_INPT); // CE1
    8ef4:	e3a01000 	mov	r1, #0
    8ef8:	e3a00007 	mov	r0, #7
    8efc:	ebfffea8 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_24, BCM2835_GPIO_FSEL_INPT); // CE0
    8f00:	e3a01000 	mov	r1, #0
    8f04:	e3a00008 	mov	r0, #8
    8f08:	ebfffea5 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_21, BCM2835_GPIO_FSEL_INPT); // MISO
    8f0c:	e3a01000 	mov	r1, #0
    8f10:	e3a00009 	mov	r0, #9
    8f14:	ebfffea2 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_19, BCM2835_GPIO_FSEL_INPT); // MOSI
    8f18:	e3a01000 	mov	r1, #0
    8f1c:	e3a0000a 	mov	r0, #10
    8f20:	ebfffe9f 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_23, BCM2835_GPIO_FSEL_INPT); // CLK
    8f24:	e3a01000 	mov	r1, #0
    8f28:	e3a0000b 	mov	r0, #11
    8f2c:	ebfffe9c 	bl	89a4 <bcm2835_gpio_fsel>
}
    8f30:	e8bd8010 	pop	{r4, pc}

00008f34 <bcm2835_spi_setBitOrder>:

void bcm2835_spi_setBitOrder(U8 order)
{
    // BCM2835_SPI_BIT_ORDER_MSBFIRST is the only one supported by SPI0
    (void) order;
}
    8f34:	e12fff1e 	bx	lr

00008f38 <bcm2835_spi_setClockDivider>:
    *paddr = value;
    8f38:	e59f3008 	ldr	r3, [pc, #8]	; 8f48 <bcm2835_spi_setClockDivider+0x10>
    8f3c:	e5830008 	str	r0, [r3, #8]
    *paddr = value;
    8f40:	e5830008 	str	r0, [r3, #8]
// of the APB clock
void bcm2835_spi_setClockDivider(U16 divider)
{
    volatile U32* paddr = ((U32*)BCM2835_SPI0_BASE) + BCM2835_SPI0_CLK / 4;
    bcm2835_peri_write(paddr, divider);
}
    8f44:	e12fff1e 	bx	lr
    8f48:	20204000 	.word	0x20204000

00008f4c <bcm2835_spi_setDataMode>:
    U32 ret = *paddr;
    8f4c:	e59f301c 	ldr	r3, [pc, #28]	; 8f70 <bcm2835_spi_setDataMode+0x24>
    8f50:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    8f54:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    8f58:	e0220100 	eor	r0, r2, r0, lsl #2
    8f5c:	e200000c 	and	r0, r0, #12
    8f60:	e0200002 	eor	r0, r0, r2
    *paddr = value;
    8f64:	e5830000 	str	r0, [r3]
    *paddr = value;
    8f68:	e5830000 	str	r0, [r3]
void bcm2835_spi_setDataMode(U8 mode)
{
    volatile U32* paddr = ((U32*)BCM2835_SPI0_BASE) + BCM2835_SPI0_CS / 4;
    // Mask in the CPO and CPHA bits of CS
    bcm2835_peri_set_bits(paddr, mode << 2, BCM2835_SPI0_CS_CPOL | BCM2835_SPI0_CS_CPHA);
}
    8f6c:	e12fff1e 	bx	lr
    8f70:	20204000 	.word	0x20204000

00008f74 <bcm2835_spi_transfer>:
    U32 ret = *paddr;
    8f74:	e59f3070 	ldr	r3, [pc, #112]	; 8fec <bcm2835_spi_transfer+0x78>
    8f78:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    8f7c:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    8f80:	e3822030 	orr	r2, r2, #48	; 0x30
    *paddr = value;
    8f84:	e5832000 	str	r2, [r3]
    *paddr = value;
    8f88:	e5832000 	str	r2, [r3]
    U32 ret = *paddr;
    8f8c:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    8f90:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    8f94:	e3822080 	orr	r2, r2, #128	; 0x80
    *paddr = value;
    8f98:	e5832000 	str	r2, [r3]
    *paddr = value;
    8f9c:	e5832000 	str	r2, [r3]
    U32 ret = *paddr;
    8fa0:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    8fa4:	e5931000 	ldr	r1, [r3]

    // Set TA = 1
    bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_TA, BCM2835_SPI0_CS_TA);

    // Maybe wait for TXD
    while (!(bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_TXD));
    8fa8:	e3120701 	tst	r2, #262144	; 0x40000
    8fac:	0afffffb 	beq	8fa0 <bcm2835_spi_transfer+0x2c>
    *paddr = value;
    8fb0:	e59f3034 	ldr	r3, [pc, #52]	; 8fec <bcm2835_spi_transfer+0x78>
    8fb4:	e5830004 	str	r0, [r3, #4]
    return *paddr;
    8fb8:	e1a02003 	mov	r2, r3
    8fbc:	e5923000 	ldr	r3, [r2]

    // Write to FIFO, no barrier
    bcm2835_peri_write_nb(fifo, value);

    // Wait for DONE to be set
    while (!(bcm2835_peri_read_nb(paddr) & BCM2835_SPI0_CS_DONE));
    8fc0:	e3130801 	tst	r3, #65536	; 0x10000
    8fc4:	0afffffc 	beq	8fbc <bcm2835_spi_transfer+0x48>
    return *paddr;
    8fc8:	e59f301c 	ldr	r3, [pc, #28]	; 8fec <bcm2835_spi_transfer+0x78>
    8fcc:	e5930004 	ldr	r0, [r3, #4]
    U32 ret = *paddr;
    8fd0:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    8fd4:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    8fd8:	e3c22080 	bic	r2, r2, #128	; 0x80
    *paddr = value;
    8fdc:	e5832000 	str	r2, [r3]
    *paddr = value;
    8fe0:	e5832000 	str	r2, [r3]

    // Set TA = 0, and also set the barrier
    bcm2835_peri_set_bits(paddr, 0, BCM2835_SPI0_CS_TA);

    return ret;
}
    8fe4:	e6ef0070 	uxtb	r0, r0
    8fe8:	e12fff1e 	bx	lr
    8fec:	20204000 	.word	0x20204000

00008ff0 <bcm2835_spi_transfernb>:

// Writes (and reads) an number of bytes to SPI
void bcm2835_spi_transfernb(const U8* tbuf, U8* rbuf, U32 len)
{
    8ff0:	e92d4070 	push	{r4, r5, r6, lr}
    8ff4:	e1a04000 	mov	r4, r0
    8ff8:	e1a05001 	mov	r5, r1
    U32 ret = *paddr;
    8ffc:	e59f3110 	ldr	r3, [pc, #272]	; 9114 <bcm2835_spi_transfernb+0x124>
    9000:	e5930000 	ldr	r0, [r3]
    *paddr; // Read without assigning to an unused variable
    9004:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    9008:	e3800030 	orr	r0, r0, #48	; 0x30
    *paddr = value;
    900c:	e5830000 	str	r0, [r3]
    *paddr = value;
    9010:	e5830000 	str	r0, [r3]
    U32 ret = *paddr;
    9014:	e5930000 	ldr	r0, [r3]
    *paddr; // Read without assigning to an unused variable
    9018:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    901c:	e3800080 	orr	r0, r0, #128	; 0x80
    *paddr = value;
    9020:	e5830000 	str	r0, [r3]
    *paddr = value;
    9024:	e5830000 	str	r0, [r3]

    // Set TA = 1
    bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_TA, BCM2835_SPI0_CS_TA);

    // Use the FIFO's to reduce the interbyte times
    while ((TXCnt < len) || (RXCnt < len))
    9028:	e2521000 	subs	r1, r2, #0
    U32 RXCnt = 0;
    902c:	13a02000 	movne	r2, #0
    U32 TXCnt = 0;
    9030:	11a0c002 	movne	ip, r2
    U32 ret = *paddr;
    9034:	159f30d8 	ldrne	r3, [pc, #216]	; 9114 <bcm2835_spi_transfernb+0x124>
    while ((TXCnt < len) || (RXCnt < len))
    9038:	0a00002a 	beq	90e8 <bcm2835_spi_transfernb+0xf8>
    U32 ret = *paddr;
    903c:	e593e000 	ldr	lr, [r3]
    *paddr; // Read without assigning to an unused variable
    9040:	e5930000 	ldr	r0, [r3]
    {
        // TX fifo not full, so add some more bytes
        while (((bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_TXD)) && (TXCnt < len))
    9044:	e151000c 	cmp	r1, ip
    9048:	93a00000 	movls	r0, #0
    904c:	83a00001 	movhi	r0, #1
    9050:	e010092e 	ands	r0, r0, lr, lsr #18
    9054:	124c0001 	subne	r0, ip, #1
    9058:	10840000 	addne	r0, r4, r0
    905c:	0a000009 	beq	9088 <bcm2835_spi_transfernb+0x98>
        {
            bcm2835_peri_write_nb(fifo, tbuf[TXCnt]);
    9060:	e5f0e001 	ldrb	lr, [r0, #1]!
    *paddr = value;
    9064:	e583e004 	str	lr, [r3, #4]
            TXCnt++;
    9068:	e28cc001 	add	ip, ip, #1
    U32 ret = *paddr;
    906c:	e5936000 	ldr	r6, [r3]
    *paddr; // Read without assigning to an unused variable
    9070:	e593e000 	ldr	lr, [r3]
        while (((bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_TXD)) && (TXCnt < len))
    9074:	e151000c 	cmp	r1, ip
    9078:	93a0e000 	movls	lr, #0
    907c:	83a0e001 	movhi	lr, #1
    9080:	e01ee926 	ands	lr, lr, r6, lsr #18
    9084:	1afffff5 	bne	9060 <bcm2835_spi_transfernb+0x70>
    U32 ret = *paddr;
    9088:	e593e000 	ldr	lr, [r3]
    *paddr; // Read without assigning to an unused variable
    908c:	e5930000 	ldr	r0, [r3]
        }
        //Rx fifo not empty, so get the next received bytes
        while (((bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)) && (RXCnt < len))
    9090:	e1510002 	cmp	r1, r2
    9094:	93a00000 	movls	r0, #0
    9098:	83a00001 	movhi	r0, #1
    909c:	e01008ae 	ands	r0, r0, lr, lsr #17
    90a0:	0a00000b 	beq	90d4 <bcm2835_spi_transfernb+0xe4>
    90a4:	e2420001 	sub	r0, r2, #1
    90a8:	e0850000 	add	r0, r5, r0
    return *paddr;
    90ac:	e593e004 	ldr	lr, [r3, #4]
        {
            rbuf[RXCnt] = bcm2835_peri_read_nb(fifo);
    90b0:	e5e0e001 	strb	lr, [r0, #1]!
            RXCnt++;
    90b4:	e2822001 	add	r2, r2, #1
    U32 ret = *paddr;
    90b8:	e5936000 	ldr	r6, [r3]
    *paddr; // Read without assigning to an unused variable
    90bc:	e593e000 	ldr	lr, [r3]
        while (((bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)) && (RXCnt < len))
    90c0:	e1510002 	cmp	r1, r2
    90c4:	93a0e000 	movls	lr, #0
    90c8:	83a0e001 	movhi	lr, #1
    90cc:	e01ee8a6 	ands	lr, lr, r6, lsr #17
    90d0:	1afffff5 	bne	90ac <bcm2835_spi_transfernb+0xbc>
    while ((TXCnt < len) || (RXCnt < len))
    90d4:	e15c0002 	cmp	ip, r2
    90d8:	31a0000c 	movcc	r0, ip
    90dc:	21a00002 	movcs	r0, r2
    90e0:	e1500001 	cmp	r0, r1
    90e4:	3affffd4 	bcc	903c <bcm2835_spi_transfernb+0x4c>
    return *paddr;
    90e8:	e59f2024 	ldr	r2, [pc, #36]	; 9114 <bcm2835_spi_transfernb+0x124>
    90ec:	e5923000 	ldr	r3, [r2]
        }
    }
    // Wait for DONE to be set
    while (!(bcm2835_peri_read_nb(paddr) & BCM2835_SPI0_CS_DONE));
    90f0:	e3130801 	tst	r3, #65536	; 0x10000
    90f4:	0afffffc 	beq	90ec <bcm2835_spi_transfernb+0xfc>
    U32 ret = *paddr;
    90f8:	e59f3014 	ldr	r3, [pc, #20]	; 9114 <bcm2835_spi_transfernb+0x124>
    90fc:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9100:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    9104:	e3c22080 	bic	r2, r2, #128	; 0x80
    *paddr = value;
    9108:	e5832000 	str	r2, [r3]
    *paddr = value;
    910c:	e5832000 	str	r2, [r3]

    // Set TA = 0, and also set the barrier
    bcm2835_peri_set_bits(paddr, 0, BCM2835_SPI0_CS_TA);
}
    9110:	e8bd8070 	pop	{r4, r5, r6, pc}
    9114:	20204000 	.word	0x20204000

00009118 <bcm2835_spi_writenb>:
    U32 ret = *paddr;
    9118:	e59f30e4 	ldr	r3, [pc, #228]	; 9204 <bcm2835_spi_writenb+0xec>
    911c:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9120:	e593c000 	ldr	ip, [r3]
    v = (v & ~mask) | (value & mask);
    9124:	e3822030 	orr	r2, r2, #48	; 0x30
    *paddr = value;
    9128:	e5832000 	str	r2, [r3]
    *paddr = value;
    912c:	e5832000 	str	r2, [r3]
    U32 ret = *paddr;
    9130:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9134:	e593c000 	ldr	ip, [r3]
    v = (v & ~mask) | (value & mask);
    9138:	e3822080 	orr	r2, r2, #128	; 0x80
    *paddr = value;
    913c:	e5832000 	str	r2, [r3]
    *paddr = value;
    9140:	e5832000 	str	r2, [r3]

    // Set TA = 1
    bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_TA, BCM2835_SPI0_CS_TA);

    U32 i;
    for (i = 0; i < len; i++)
    9144:	e3510000 	cmp	r1, #0
    9148:	0a000013 	beq	919c <bcm2835_spi_writenb+0x84>
    914c:	e240c001 	sub	ip, r0, #1
    9150:	e0800001 	add	r0, r0, r1
    9154:	e2400001 	sub	r0, r0, #1
    U32 ret = *paddr;
    9158:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    915c:	e5931000 	ldr	r1, [r3]
    {
        // Maybe wait for TXD
        while (!(bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_TXD));
    9160:	e3120701 	tst	r2, #262144	; 0x40000
    9164:	0afffffb 	beq	9158 <bcm2835_spi_writenb+0x40>

        // Write to FIFO, no barrier
        bcm2835_peri_write_nb(fifo, tbuf[i]);
    9168:	e5fc2001 	ldrb	r2, [ip, #1]!
    *paddr = value;
    916c:	e5832004 	str	r2, [r3, #4]
    U32 ret = *paddr;
    9170:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9174:	e5931000 	ldr	r1, [r3]

        // Read from FIFO to prevent stalling
        while (bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)
    9178:	e3120802 	tst	r2, #131072	; 0x20000
    917c:	0a000004 	beq	9194 <bcm2835_spi_writenb+0x7c>
    return *paddr;
    9180:	e5932004 	ldr	r2, [r3, #4]
    U32 ret = *paddr;
    9184:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9188:	e5931000 	ldr	r1, [r3]
        while (bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)
    918c:	e3120802 	tst	r2, #131072	; 0x20000
    9190:	1afffffa 	bne	9180 <bcm2835_spi_writenb+0x68>
    for (i = 0; i < len; i++)
    9194:	e150000c 	cmp	r0, ip
    9198:	1affffee 	bne	9158 <bcm2835_spi_writenb+0x40>
    return *paddr;
    919c:	e59f3060 	ldr	r3, [pc, #96]	; 9204 <bcm2835_spi_writenb+0xec>
    91a0:	e5933000 	ldr	r3, [r3]
            (void) bcm2835_peri_read_nb(fifo);
    }

    // Wait for DONE to be set
    while (!(bcm2835_peri_read_nb(paddr) & BCM2835_SPI0_CS_DONE))
    91a4:	e3130801 	tst	r3, #65536	; 0x10000
    91a8:	1a00000e 	bne	91e8 <bcm2835_spi_writenb+0xd0>
    U32 ret = *paddr;
    91ac:	e59f3050 	ldr	r3, [pc, #80]	; 9204 <bcm2835_spi_writenb+0xec>
    91b0:	ea000007 	b	91d4 <bcm2835_spi_writenb+0xbc>
    return *paddr;
    91b4:	e5932004 	ldr	r2, [r3, #4]
    U32 ret = *paddr;
    91b8:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    91bc:	e5931000 	ldr	r1, [r3]
    {
        while (bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)
    91c0:	e3120802 	tst	r2, #131072	; 0x20000
    91c4:	1afffffa 	bne	91b4 <bcm2835_spi_writenb+0x9c>
    return *paddr;
    91c8:	e5932000 	ldr	r2, [r3]
    while (!(bcm2835_peri_read_nb(paddr) & BCM2835_SPI0_CS_DONE))
    91cc:	e3120801 	tst	r2, #65536	; 0x10000
    91d0:	1a000004 	bne	91e8 <bcm2835_spi_writenb+0xd0>
    U32 ret = *paddr;
    91d4:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    91d8:	e5931000 	ldr	r1, [r3]
        while (bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_RXD)
    91dc:	e3120802 	tst	r2, #131072	; 0x20000
    91e0:	1afffff3 	bne	91b4 <bcm2835_spi_writenb+0x9c>
    91e4:	eafffff7 	b	91c8 <bcm2835_spi_writenb+0xb0>
    U32 ret = *paddr;
    91e8:	e59f3014 	ldr	r3, [pc, #20]	; 9204 <bcm2835_spi_writenb+0xec>
    91ec:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    91f0:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    91f4:	e3c22080 	bic	r2, r2, #128	; 0x80
    *paddr = value;
    91f8:	e5832000 	str	r2, [r3]
    *paddr = value;
    91fc:	e5832000 	str	r2, [r3]
            (void) bcm2835_peri_read_nb(fifo);
    }

    // Set TA = 0, and also set the barrier
    bcm2835_peri_set_bits(paddr, 0, BCM2835_SPI0_CS_TA);
}
    9200:	e12fff1e 	bx	lr
    9204:	20204000 	.word	0x20204000

00009208 <bcm2835_spi_transfern>:

// Writes (and reads) an number of bytes to SPI
// Read bytes are copied over onto the transmit buffer
void bcm2835_spi_transfern(U8* buf, U32 len)
{
    9208:	e92d4010 	push	{r4, lr}
    920c:	e1a02001 	mov	r2, r1
    bcm2835_spi_transfernb(buf, buf, len);
    9210:	e1a01000 	mov	r1, r0
    9214:	ebffff75 	bl	8ff0 <bcm2835_spi_transfernb>
}
    9218:	e8bd8010 	pop	{r4, pc}

0000921c <bcm2835_spi_chipSelect>:
    U32 ret = *paddr;
    921c:	e59f301c 	ldr	r3, [pc, #28]	; 9240 <bcm2835_spi_chipSelect+0x24>
    9220:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9224:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    9228:	e0200002 	eor	r0, r0, r2
    922c:	e2000003 	and	r0, r0, #3
    9230:	e0200002 	eor	r0, r0, r2
    *paddr = value;
    9234:	e5830000 	str	r0, [r3]
    *paddr = value;
    9238:	e5830000 	str	r0, [r3]
void bcm2835_spi_chipSelect(U8 cs)
{
    volatile U32* paddr = ((U32*)BCM2835_SPI0_BASE) + BCM2835_SPI0_CS / 4;
    // Mask in the CS bits of CS
    bcm2835_peri_set_bits(paddr, cs, BCM2835_SPI0_CS_CS);
}
    923c:	e12fff1e 	bx	lr
    9240:	20204000 	.word	0x20204000

00009244 <bcm2835_spi_setChipSelectPolarity>:

void bcm2835_spi_setChipSelectPolarity(U8 cs, U8 active)
{
    volatile U32* paddr = ((U32*)BCM2835_SPI0_BASE) + BCM2835_SPI0_CS / 4;
    U8 shift = 21 + cs;
    9244:	e2800015 	add	r0, r0, #21
    // Mask in the appropriate CSPOLn bit
    bcm2835_peri_set_bits(paddr, active << shift, 1 << shift);
    9248:	e6ef0070 	uxtb	r0, r0
    U32 ret = *paddr;
    924c:	e59f3020 	ldr	r3, [pc, #32]	; 9274 <bcm2835_spi_setChipSelectPolarity+0x30>
    9250:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9254:	e593c000 	ldr	ip, [r3]
    v = (v & ~mask) | (value & mask);
    9258:	e0221011 	eor	r1, r2, r1, lsl r0
    925c:	e3a0c001 	mov	ip, #1
    9260:	e001101c 	and	r1, r1, ip, lsl r0
    9264:	e0211002 	eor	r1, r1, r2
    *paddr = value;
    9268:	e5831000 	str	r1, [r3]
    *paddr = value;
    926c:	e5831000 	str	r1, [r3]
}
    9270:	e12fff1e 	bx	lr
    9274:	20204000 	.word	0x20204000

00009278 <bcm2835_i2c_begin>:

void bcm2835_i2c_begin(void)
{
    9278:	e92d4010 	push	{r4, lr}
    bcm2835_gpio_fsel(RPI_GPIO_P1_03, BCM2835_GPIO_FSEL_ALT0); // SDA
    bcm2835_gpio_fsel(RPI_GPIO_P1_05, BCM2835_GPIO_FSEL_ALT0); // SCL
#else
    volatile U32* paddr = ((U32*)BCM2835_BSC1_BASE) + BCM2835_BSC_DIV / 4;
    // Set the I2C/BSC1 pins to the Alt 0 function to enable I2C access on them
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_03, BCM2835_GPIO_FSEL_ALT0); // SDA
    927c:	e3a01004 	mov	r1, #4
    9280:	e3a00002 	mov	r0, #2
    9284:	ebfffdc6 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_05, BCM2835_GPIO_FSEL_ALT0); // SCL
    9288:	e3a01004 	mov	r1, #4
    928c:	e3a00003 	mov	r0, #3
    9290:	ebfffdc3 	bl	89a4 <bcm2835_gpio_fsel>
    U32 ret = *paddr;
    9294:	e59f3034 	ldr	r3, [pc, #52]	; 92d0 <bcm2835_i2c_begin+0x58>
    9298:	e5930014 	ldr	r0, [r3, #20]
    *paddr; // Read without assigning to an unused variable
    929c:	e5933014 	ldr	r3, [r3, #20]
    // Read the clock divider register
    U16 cdiv = bcm2835_peri_read(paddr);
    // Calculate time for transmitting one byte
    // 1000000 = micros seconds in a second
    // 9 = Clocks per byte : 8 bits + ACK
    i2c_byte_wait_us = (I32)(((float) cdiv / BCM2835_CORE_CLK_HZ) * 1000000 * 9);
    92a0:	e6ff0070 	uxth	r0, r0
    92a4:	eb00049f 	bl	a528 <__aeabi_ui2f>
    92a8:	e59f1024 	ldr	r1, [pc, #36]	; 92d4 <bcm2835_i2c_begin+0x5c>
    92ac:	eb00053c 	bl	a7a4 <__aeabi_fdiv>
    92b0:	e59f1020 	ldr	r1, [pc, #32]	; 92d8 <bcm2835_i2c_begin+0x60>
    92b4:	eb0004d4 	bl	a60c <__aeabi_fmul>
    92b8:	e59f101c 	ldr	r1, [pc, #28]	; 92dc <bcm2835_i2c_begin+0x64>
    92bc:	eb0004d2 	bl	a60c <__aeabi_fmul>
    92c0:	eb00058f 	bl	a904 <__aeabi_f2iz>
    92c4:	e59f3014 	ldr	r3, [pc, #20]	; 92e0 <bcm2835_i2c_begin+0x68>
    92c8:	e5830000 	str	r0, [r3]
}
    92cc:	e8bd8010 	pop	{r4, pc}
    92d0:	20804000 	.word	0x20804000
    92d4:	4e6e6b28 	.word	0x4e6e6b28
    92d8:	49742400 	.word	0x49742400
    92dc:	41100000 	.word	0x41100000
    92e0:	0001ad28 	.word	0x0001ad28

000092e4 <bcm2835_i2c_end>:

void bcm2835_i2c_end(void)
{
    92e4:	e92d4010 	push	{r4, lr}
    // Set all the I2C/BSC0 pins back to input
    bcm2835_gpio_fsel(RPI_GPIO_P1_03, BCM2835_GPIO_FSEL_INPT); // SDA
    bcm2835_gpio_fsel(RPI_GPIO_P1_05, BCM2835_GPIO_FSEL_INPT); // SCL
#else
    // Set all the I2C/BSC1 pins back to input
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_03, BCM2835_GPIO_FSEL_INPT); // SDA
    92e8:	e3a01000 	mov	r1, #0
    92ec:	e3a00002 	mov	r0, #2
    92f0:	ebfffdab 	bl	89a4 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_05, BCM2835_GPIO_FSEL_INPT); // SCL
    92f4:	e3a01000 	mov	r1, #0
    92f8:	e3a00003 	mov	r0, #3
    92fc:	ebfffda8 	bl	89a4 <bcm2835_gpio_fsel>
#endif
}
    9300:	e8bd8010 	pop	{r4, pc}

00009304 <bcm2835_i2c_setSlaveAddress>:
    *paddr = value;
    9304:	e59f3008 	ldr	r3, [pc, #8]	; 9314 <bcm2835_i2c_setSlaveAddress+0x10>
    9308:	e583000c 	str	r0, [r3, #12]
    *paddr = value;
    930c:	e583000c 	str	r0, [r3, #12]
    volatile U32* paddr = ((U32*)BCM2835_BSC0_BASE) + BCM2835_BSC_A/4;
#else
    volatile U32* paddr = ((U32*)BCM2835_BSC1_BASE) + BCM2835_BSC_A / 4;
#endif
    bcm2835_peri_write(paddr, addr);
}
    9310:	e12fff1e 	bx	lr
    9314:	20804000 	.word	0x20804000

00009318 <bcm2835_i2c_setClockDivider>:

// defaults to 0x5dc, should result in a 166.666 kHz I2C clock frequency.
// The divisor must be a power of 2. Odd numbers
// rounded down.
void bcm2835_i2c_setClockDivider(U16 divider)
{
    9318:	e92d4010 	push	{r4, lr}
    *paddr = value;
    931c:	e59f2030 	ldr	r2, [pc, #48]	; 9354 <bcm2835_i2c_setClockDivider+0x3c>
    9320:	e5820014 	str	r0, [r2, #20]
    *paddr = value;
    9324:	e5820014 	str	r0, [r2, #20]
#endif
    bcm2835_peri_write(paddr, divider);
    // Calculate time for transmitting one byte
    // 1000000 = micros seconds in a second
    // 9 = Clocks per byte : 8 bits + ACK
    i2c_byte_wait_us = (I32)(((float) divider / BCM2835_CORE_CLK_HZ) * 1000000 * 9);
    9328:	eb00047e 	bl	a528 <__aeabi_ui2f>
    932c:	e59f1024 	ldr	r1, [pc, #36]	; 9358 <bcm2835_i2c_setClockDivider+0x40>
    9330:	eb00051b 	bl	a7a4 <__aeabi_fdiv>
    9334:	e59f1020 	ldr	r1, [pc, #32]	; 935c <bcm2835_i2c_setClockDivider+0x44>
    9338:	eb0004b3 	bl	a60c <__aeabi_fmul>
    933c:	e59f101c 	ldr	r1, [pc, #28]	; 9360 <bcm2835_i2c_setClockDivider+0x48>
    9340:	eb0004b1 	bl	a60c <__aeabi_fmul>
    9344:	eb00056e 	bl	a904 <__aeabi_f2iz>
    9348:	e59f3014 	ldr	r3, [pc, #20]	; 9364 <bcm2835_i2c_setClockDivider+0x4c>
    934c:	e5830000 	str	r0, [r3]
}
    9350:	e8bd8010 	pop	{r4, pc}
    9354:	20804000 	.word	0x20804000
    9358:	4e6e6b28 	.word	0x4e6e6b28
    935c:	49742400 	.word	0x49742400
    9360:	41100000 	.word	0x41100000
    9364:	0001ad28 	.word	0x0001ad28

00009368 <bcm2835_i2c_set_baudrate>:

// set I2C clock divider by means of a baudrate number
void bcm2835_i2c_set_baudrate(U32 baudrate)
{
    9368:	e92d4010 	push	{r4, lr}
    936c:	e1a01000 	mov	r1, r0
    U32 divider;
    // use 0xFFFE mask to limit a max value and round down any odd number
    divider = (BCM2835_CORE_CLK_HZ / baudrate) & 0xFFFE;
    9370:	e59f0014 	ldr	r0, [pc, #20]	; 938c <bcm2835_i2c_set_baudrate+0x24>
    9374:	eb000226 	bl	9c14 <__udivsi3>
    9378:	e1a03000 	mov	r3, r0
    bcm2835_i2c_setClockDivider((U16) divider);
    937c:	e59f000c 	ldr	r0, [pc, #12]	; 9390 <bcm2835_i2c_set_baudrate+0x28>
    9380:	e0000003 	and	r0, r0, r3
    9384:	ebffffe3 	bl	9318 <bcm2835_i2c_setClockDivider>
}
    9388:	e8bd8010 	pop	{r4, pc}
    938c:	3b9aca00 	.word	0x3b9aca00
    9390:	0000fffe 	.word	0x0000fffe

00009394 <bcm2835_i2c_write>:

// Writes an number of bytes to I2C
U8 bcm2835_i2c_write(const U8* buf, U32 len)
{
    9394:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    U32 ret = *paddr;
    9398:	e59f311c 	ldr	r3, [pc, #284]	; 94bc <bcm2835_i2c_write+0x128>
    939c:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    93a0:	e593c000 	ldr	ip, [r3]
    v = (v & ~mask) | (value & mask);
    93a4:	e3822020 	orr	r2, r2, #32
    *paddr = value;
    93a8:	e5832000 	str	r2, [r3]
    *paddr = value;
    93ac:	e5832000 	str	r2, [r3]
    *paddr = value;
    93b0:	e59f2108 	ldr	r2, [pc, #264]	; 94c0 <bcm2835_i2c_write+0x12c>
    93b4:	e5832004 	str	r2, [r3, #4]
    93b8:	e5831008 	str	r1, [r3, #8]
    // Clear Status
    bcm2835_peri_write_nb(status, BCM2835_BSC_S_CLKT | BCM2835_BSC_S_ERR | BCM2835_BSC_S_DONE);
    // Set Data Length
    bcm2835_peri_write_nb(dlen, len);
    // pre populate FIFO with max buffer
    while (remaining && (i < BCM2835_BSC_FIFO_SIZE))
    93bc:	e3510000 	cmp	r1, #0
    93c0:	0a000015 	beq	941c <bcm2835_i2c_write+0x88>
    93c4:	e240c001 	sub	ip, r0, #1
    U32 i = 0;
    93c8:	e3a03000 	mov	r3, #0
    *paddr = value;
    93cc:	e59fe0e8 	ldr	lr, [pc, #232]	; 94bc <bcm2835_i2c_write+0x128>
    {
        bcm2835_peri_write_nb(fifo, buf[i]);
    93d0:	e5fc2001 	ldrb	r2, [ip, #1]!
    *paddr = value;
    93d4:	e58e2010 	str	r2, [lr, #16]
        i++;
    93d8:	e2833001 	add	r3, r3, #1
    while (remaining && (i < BCM2835_BSC_FIFO_SIZE))
    93dc:	e2511001 	subs	r1, r1, #1
    93e0:	13a02001 	movne	r2, #1
    93e4:	03a02000 	moveq	r2, #0
    93e8:	e353000f 	cmp	r3, #15
    93ec:	83a02000 	movhi	r2, #0
    93f0:	92022001 	andls	r2, r2, #1
    93f4:	e3520000 	cmp	r2, #0
    93f8:	1afffff4 	bne	93d0 <bcm2835_i2c_write+0x3c>
    *paddr = value;
    93fc:	e59f20b8 	ldr	r2, [pc, #184]	; 94bc <bcm2835_i2c_write+0x128>
    9400:	e59fc0bc 	ldr	ip, [pc, #188]	; 94c4 <bcm2835_i2c_write+0x130>
    9404:	e582c000 	str	ip, [r2]
    return *paddr;
    9408:	e5922004 	ldr	r2, [r2, #4]

    // Enable device and start transfer
    bcm2835_peri_write_nb(control, BCM2835_BSC_C_I2CEN | BCM2835_BSC_C_ST);

    // Transfer is over when BCM2835_BSC_S_DONE
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    940c:	e3120002 	tst	r2, #2
    9410:	1a000013 	bne	9464 <bcm2835_i2c_write+0xd0>
    return *paddr;
    9414:	e59fc0a0 	ldr	ip, [pc, #160]	; 94bc <bcm2835_i2c_write+0x128>
    9418:	ea000004 	b	9430 <bcm2835_i2c_write+0x9c>
    U32 i = 0;
    941c:	e1a03001 	mov	r3, r1
    9420:	eafffff5 	b	93fc <bcm2835_i2c_write+0x68>
    return *paddr;
    9424:	e59c2004 	ldr	r2, [ip, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    9428:	e3120002 	tst	r2, #2
    942c:	1a00000c 	bne	9464 <bcm2835_i2c_write+0xd0>
    {
        while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_TXD))
    9430:	e3510000 	cmp	r1, #0
    9434:	0afffffa 	beq	9424 <bcm2835_i2c_write+0x90>
    9438:	e2432001 	sub	r2, r3, #1
    943c:	e0802002 	add	r2, r0, r2
    return *paddr;
    9440:	e59ce004 	ldr	lr, [ip, #4]
        while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_TXD))
    9444:	e31e0010 	tst	lr, #16
    9448:	0afffff5 	beq	9424 <bcm2835_i2c_write+0x90>
        {
            // Write to FIFO, no barrier
            bcm2835_peri_write_nb(fifo, buf[i]);
    944c:	e5f2e001 	ldrb	lr, [r2, #1]!
    *paddr = value;
    9450:	e58ce010 	str	lr, [ip, #16]
            i++;
    9454:	e2833001 	add	r3, r3, #1
        while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_TXD))
    9458:	e2511001 	subs	r1, r1, #1
    945c:	1afffff7 	bne	9440 <bcm2835_i2c_write+0xac>
    9460:	eaffffef 	b	9424 <bcm2835_i2c_write+0x90>
    U32 ret = *paddr;
    9464:	e59f3050 	ldr	r3, [pc, #80]	; 94bc <bcm2835_i2c_write+0x128>
    9468:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    946c:	e5933004 	ldr	r3, [r3, #4]
            remaining--;
        }
    }

    // Received a NACK
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9470:	e3120c01 	tst	r2, #256	; 0x100
    {
        reason = BCM2835_I2C_REASON_ERROR_NACK;
    9474:	13a00001 	movne	r0, #1
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9478:	1a000008 	bne	94a0 <bcm2835_i2c_write+0x10c>
    U32 ret = *paddr;
    947c:	e59f3038 	ldr	r3, [pc, #56]	; 94bc <bcm2835_i2c_write+0x128>
    9480:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    9484:	e5933004 	ldr	r3, [r3, #4]
    }

        // Received Clock Stretch Timeout
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9488:	e3120c02 	tst	r2, #512	; 0x200
    {
        reason = BCM2835_I2C_REASON_ERROR_CLKT;
    948c:	13a00002 	movne	r0, #2
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9490:	1a000002 	bne	94a0 <bcm2835_i2c_write+0x10c>
    }

        // Not all data is sent
    else if (remaining)
    9494:	e2511000 	subs	r1, r1, #0
    9498:	13a01001 	movne	r1, #1
    949c:	e1a00101 	lsl	r0, r1, #2
    U32 ret = *paddr;
    94a0:	e59f3014 	ldr	r3, [pc, #20]	; 94bc <bcm2835_i2c_write+0x128>
    94a4:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    94a8:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    94ac:	e3822002 	orr	r2, r2, #2
    *paddr = value;
    94b0:	e5832000 	str	r2, [r3]
    *paddr = value;
    94b4:	e5832000 	str	r2, [r3]
    }

    bcm2835_peri_set_bits(control, BCM2835_BSC_S_DONE, BCM2835_BSC_S_DONE);

    return reason;
}
    94b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    94bc:	20804000 	.word	0x20804000
    94c0:	00000302 	.word	0x00000302
    94c4:	00008080 	.word	0x00008080

000094c8 <bcm2835_i2c_read>:

// Read an number of bytes from I2C
U8 bcm2835_i2c_read(U8* buf, U32 len)
{
    94c8:	e92d4010 	push	{r4, lr}
    94cc:	e1a04000 	mov	r4, r0
    94d0:	e1a00001 	mov	r0, r1
    U32 ret = *paddr;
    94d4:	e59f310c 	ldr	r3, [pc, #268]	; 95e8 <bcm2835_i2c_read+0x120>
    94d8:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    94dc:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    94e0:	e3822020 	orr	r2, r2, #32
    *paddr = value;
    94e4:	e5832000 	str	r2, [r3]
    *paddr = value;
    94e8:	e5832000 	str	r2, [r3]
    *paddr = value;
    94ec:	e59f20f8 	ldr	r2, [pc, #248]	; 95ec <bcm2835_i2c_read+0x124>
    94f0:	e5832004 	str	r2, [r3, #4]
    94f4:	e5830008 	str	r0, [r3, #8]
    94f8:	e59f20f0 	ldr	r2, [pc, #240]	; 95f0 <bcm2835_i2c_read+0x128>
    94fc:	e5832000 	str	r2, [r3]
    return *paddr;
    9500:	e5933004 	ldr	r3, [r3, #4]
    bcm2835_peri_write_nb(dlen, len);
    // Start read
    bcm2835_peri_write_nb(control, BCM2835_BSC_C_I2CEN | BCM2835_BSC_C_ST | BCM2835_BSC_C_READ);

    // wait for transfer to complete
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    9504:	e2131002 	ands	r1, r3, #2
    return *paddr;
    9508:	059fc0d8 	ldreq	ip, [pc, #216]	; 95e8 <bcm2835_i2c_read+0x120>
    950c:	0a00002d 	beq	95c8 <bcm2835_i2c_read+0x100>
    U32 i = 0;
    9510:	e3a01000 	mov	r1, #0
            remaining--;
        }
    }

    // transfer has finished - grab any remaining stuff in FIFO
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    9514:	e3500000 	cmp	r0, #0
    9518:	0a000009 	beq	9544 <bcm2835_i2c_read+0x7c>
    951c:	e2413001 	sub	r3, r1, #1
    9520:	e0843003 	add	r3, r4, r3
    return *paddr;
    9524:	e59f20bc 	ldr	r2, [pc, #188]	; 95e8 <bcm2835_i2c_read+0x120>
    9528:	e5921004 	ldr	r1, [r2, #4]
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    952c:	e3110020 	tst	r1, #32
    9530:	0a000003 	beq	9544 <bcm2835_i2c_read+0x7c>
    return *paddr;
    9534:	e5921010 	ldr	r1, [r2, #16]
    {
        // Read from FIFO, no barrier
        buf[i] = bcm2835_peri_read_nb(fifo);
    9538:	e5e31001 	strb	r1, [r3, #1]!
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    953c:	e2500001 	subs	r0, r0, #1
    9540:	1afffff8 	bne	9528 <bcm2835_i2c_read+0x60>
    U32 ret = *paddr;
    9544:	e59f309c 	ldr	r3, [pc, #156]	; 95e8 <bcm2835_i2c_read+0x120>
    9548:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    954c:	e5933004 	ldr	r3, [r3, #4]
        i++;
        remaining--;
    }

    // Received a NACK
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9550:	e3120c01 	tst	r2, #256	; 0x100
    {
        reason = BCM2835_I2C_REASON_ERROR_NACK;
    9554:	13a00001 	movne	r0, #1
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9558:	1a000008 	bne	9580 <bcm2835_i2c_read+0xb8>
    U32 ret = *paddr;
    955c:	e59f3084 	ldr	r3, [pc, #132]	; 95e8 <bcm2835_i2c_read+0x120>
    9560:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    9564:	e5933004 	ldr	r3, [r3, #4]
    }

        // Received Clock Stretch Timeout
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9568:	e3120c02 	tst	r2, #512	; 0x200
    {
        reason = BCM2835_I2C_REASON_ERROR_CLKT;
    956c:	13a00002 	movne	r0, #2
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9570:	1a000002 	bne	9580 <bcm2835_i2c_read+0xb8>
    }

        // Not all data is received
    else if (remaining)
    9574:	e2500000 	subs	r0, r0, #0
    9578:	13a00001 	movne	r0, #1
    957c:	e1a00100 	lsl	r0, r0, #2
    U32 ret = *paddr;
    9580:	e59f3060 	ldr	r3, [pc, #96]	; 95e8 <bcm2835_i2c_read+0x120>
    9584:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9588:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    958c:	e3822002 	orr	r2, r2, #2
    *paddr = value;
    9590:	e5832000 	str	r2, [r3]
    *paddr = value;
    9594:	e5832000 	str	r2, [r3]
    }

    bcm2835_peri_set_bits(control, BCM2835_BSC_S_DONE, BCM2835_BSC_S_DONE);

    return reason;
}
    9598:	e8bd8010 	pop	{r4, pc}
    return *paddr;
    959c:	e59ce010 	ldr	lr, [ip, #16]
            buf[i] = bcm2835_peri_read_nb(fifo);
    95a0:	e5e2e001 	strb	lr, [r2, #1]!
            i++;
    95a4:	e2833001 	add	r3, r3, #1
            remaining--;
    95a8:	e0410003 	sub	r0, r1, r3
    return *paddr;
    95ac:	e59ce004 	ldr	lr, [ip, #4]
        while (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    95b0:	e31e0020 	tst	lr, #32
    95b4:	1afffff8 	bne	959c <bcm2835_i2c_read+0xd4>
            i++;
    95b8:	e1a01003 	mov	r1, r3
    return *paddr;
    95bc:	e59c3004 	ldr	r3, [ip, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    95c0:	e3130002 	tst	r3, #2
    95c4:	1affffd2 	bne	9514 <bcm2835_i2c_read+0x4c>
    return *paddr;
    95c8:	e59c3004 	ldr	r3, [ip, #4]
        while (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    95cc:	e3130020 	tst	r3, #32
    95d0:	12412001 	subne	r2, r1, #1
    95d4:	10842002 	addne	r2, r4, r2
    95d8:	11a03001 	movne	r3, r1
    95dc:	10801001 	addne	r1, r0, r1
    95e0:	1affffed 	bne	959c <bcm2835_i2c_read+0xd4>
    95e4:	eafffff4 	b	95bc <bcm2835_i2c_read+0xf4>
    95e8:	20804000 	.word	0x20804000
    95ec:	00000302 	.word	0x00000302
    95f0:	00008081 	.word	0x00008081

000095f4 <bcm2835_st_read>:
    U32 ret = *paddr;
    95f4:	e59f3010 	ldr	r3, [pc, #16]	; 960c <bcm2835_st_read+0x18>
    95f8:	e5931008 	ldr	r1, [r3, #8]
    *paddr; // Read without assigning to an unused variable
    95fc:	e5932008 	ldr	r2, [r3, #8]
    U32 ret = *paddr;
    9600:	e5930004 	ldr	r0, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    9604:	e5933004 	ldr	r3, [r3, #4]
    U64 st;
    st = bcm2835_peri_read(&BCM2835_ST->CHI);
    st <<= 32;
    st += bcm2835_peri_read(&BCM2835_ST->CLO);
    return st;
}
    9608:	e12fff1e 	bx	lr
    960c:	20003000 	.word	0x20003000

00009610 <bcm2835_st_delay>:

// Delays for the specified number of microseconds with offset
void bcm2835_st_delay(U64 offset_micros, U64 micros)
{
    9610:	e92d4070 	push	{r4, r5, r6, lr}
    U64 compare = offset_micros + micros;
    9614:	e0904002 	adds	r4, r0, r2
    9618:	e0a15003 	adc	r5, r1, r3
    while (bcm2835_st_read() < compare);
    961c:	ebfffff4 	bl	95f4 <bcm2835_st_read>
    9620:	e1500004 	cmp	r0, r4
    9624:	e0d11005 	sbcs	r1, r1, r5
    9628:	3afffffb 	bcc	961c <bcm2835_st_delay+0xc>
    962c:	e8bd8070 	pop	{r4, r5, r6, pc}

00009630 <bcm2835_i2c_read_register_rs>:
{
    9630:	e92d4070 	push	{r4, r5, r6, lr}
    9634:	e1a05001 	mov	r5, r1
    9638:	e1a04002 	mov	r4, r2
    U32 ret = *paddr;
    963c:	e59f3158 	ldr	r3, [pc, #344]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    9640:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9644:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    9648:	e3822020 	orr	r2, r2, #32
    *paddr = value;
    964c:	e5832000 	str	r2, [r3]
    *paddr = value;
    9650:	e5832000 	str	r2, [r3]
    *paddr = value;
    9654:	e59f2144 	ldr	r2, [pc, #324]	; 97a0 <bcm2835_i2c_read_register_rs+0x170>
    9658:	e5832004 	str	r2, [r3, #4]
    965c:	e3a02001 	mov	r2, #1
    9660:	e5832008 	str	r2, [r3, #8]
    9664:	e3a02902 	mov	r2, #32768	; 0x8000
    9668:	e5832000 	str	r2, [r3]
    bcm2835_peri_write_nb(fifo, regaddr[0]);
    966c:	e5d02000 	ldrb	r2, [r0]
    *paddr = value;
    9670:	e5832010 	str	r2, [r3, #16]
    9674:	e59f2128 	ldr	r2, [pc, #296]	; 97a4 <bcm2835_i2c_read_register_rs+0x174>
    9678:	e5832000 	str	r2, [r3]
    return *paddr;
    967c:	e5932004 	ldr	r2, [r3, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_TA))
    9680:	e3120001 	tst	r2, #1
    9684:	1a000003 	bne	9698 <bcm2835_i2c_read_register_rs+0x68>
    U32 ret = *paddr;
    9688:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    968c:	e5931004 	ldr	r1, [r3, #4]
        if (bcm2835_peri_read(status) & BCM2835_BSC_S_DONE)
    9690:	e3120002 	tst	r2, #2
    9694:	0afffff8 	beq	967c <bcm2835_i2c_read_register_rs+0x4c>
    *paddr = value;
    9698:	e59f60fc 	ldr	r6, [pc, #252]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    969c:	e5864008 	str	r4, [r6, #8]
    96a0:	e59f3100 	ldr	r3, [pc, #256]	; 97a8 <bcm2835_i2c_read_register_rs+0x178>
    96a4:	e5863000 	str	r3, [r6]
    bcm2835_st_delay(bcm2835_st_read(), i2c_byte_wait_us * 3);
    96a8:	ebffffd1 	bl	95f4 <bcm2835_st_read>
    96ac:	e59f30f8 	ldr	r3, [pc, #248]	; 97ac <bcm2835_i2c_read_register_rs+0x17c>
    96b0:	e5932000 	ldr	r2, [r3]
    96b4:	e0822082 	add	r2, r2, r2, lsl #1
    96b8:	e1a03fc2 	asr	r3, r2, #31
    96bc:	ebffffd3 	bl	9610 <bcm2835_st_delay>
    return *paddr;
    96c0:	e5962004 	ldr	r2, [r6, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    96c4:	e2122002 	ands	r2, r2, #2
    return *paddr;
    96c8:	01a00006 	moveq	r0, r6
    96cc:	0a000025 	beq	9768 <bcm2835_i2c_read_register_rs+0x138>
    U32 i = 0;
    96d0:	e3a02000 	mov	r2, #0
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    96d4:	e3540000 	cmp	r4, #0
    96d8:	0a000009 	beq	9704 <bcm2835_i2c_read_register_rs+0xd4>
    96dc:	e2422001 	sub	r2, r2, #1
    96e0:	e0855002 	add	r5, r5, r2
    return *paddr;
    96e4:	e59f30b0 	ldr	r3, [pc, #176]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    96e8:	e5932004 	ldr	r2, [r3, #4]
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    96ec:	e3120020 	tst	r2, #32
    96f0:	0a000003 	beq	9704 <bcm2835_i2c_read_register_rs+0xd4>
    return *paddr;
    96f4:	e5932010 	ldr	r2, [r3, #16]
        buf[i] = bcm2835_peri_read_nb(fifo);
    96f8:	e5e52001 	strb	r2, [r5, #1]!
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    96fc:	e2544001 	subs	r4, r4, #1
    9700:	1afffff8 	bne	96e8 <bcm2835_i2c_read_register_rs+0xb8>
    U32 ret = *paddr;
    9704:	e59f3090 	ldr	r3, [pc, #144]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    9708:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    970c:	e5933004 	ldr	r3, [r3, #4]
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9710:	e3120c01 	tst	r2, #256	; 0x100
        reason = BCM2835_I2C_REASON_ERROR_NACK;
    9714:	13a00001 	movne	r0, #1
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    9718:	1a000008 	bne	9740 <bcm2835_i2c_read_register_rs+0x110>
    U32 ret = *paddr;
    971c:	e59f3078 	ldr	r3, [pc, #120]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    9720:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    9724:	e5933004 	ldr	r3, [r3, #4]
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9728:	e3120c02 	tst	r2, #512	; 0x200
        reason = BCM2835_I2C_REASON_ERROR_CLKT;
    972c:	13a00002 	movne	r0, #2
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    9730:	1a000002 	bne	9740 <bcm2835_i2c_read_register_rs+0x110>
    else if (remaining)
    9734:	e2540000 	subs	r0, r4, #0
    9738:	13a00001 	movne	r0, #1
    973c:	e1a00100 	lsl	r0, r0, #2
    U32 ret = *paddr;
    9740:	e59f3054 	ldr	r3, [pc, #84]	; 979c <bcm2835_i2c_read_register_rs+0x16c>
    9744:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    9748:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    974c:	e3822002 	orr	r2, r2, #2
    *paddr = value;
    9750:	e5832000 	str	r2, [r3]
    *paddr = value;
    9754:	e5832000 	str	r2, [r3]
}
    9758:	e8bd8070 	pop	{r4, r5, r6, pc}
    return *paddr;
    975c:	e5903004 	ldr	r3, [r0, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    9760:	e3130002 	tst	r3, #2
    9764:	1affffda 	bne	96d4 <bcm2835_i2c_read_register_rs+0xa4>
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    9768:	e3540000 	cmp	r4, #0
    976c:	0afffffa 	beq	975c <bcm2835_i2c_read_register_rs+0x12c>
    9770:	e2423001 	sub	r3, r2, #1
    9774:	e0853003 	add	r3, r5, r3
    return *paddr;
    9778:	e5901004 	ldr	r1, [r0, #4]
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    977c:	e3110020 	tst	r1, #32
    9780:	0afffff5 	beq	975c <bcm2835_i2c_read_register_rs+0x12c>
    return *paddr;
    9784:	e5901010 	ldr	r1, [r0, #16]
            buf[i] = bcm2835_peri_read_nb(fifo);
    9788:	e5e31001 	strb	r1, [r3, #1]!
            i++;
    978c:	e2822001 	add	r2, r2, #1
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    9790:	e2544001 	subs	r4, r4, #1
    9794:	1afffff7 	bne	9778 <bcm2835_i2c_read_register_rs+0x148>
    9798:	eaffffef 	b	975c <bcm2835_i2c_read_register_rs+0x12c>
    979c:	20804000 	.word	0x20804000
    97a0:	00000302 	.word	0x00000302
    97a4:	00008080 	.word	0x00008080
    97a8:	00008081 	.word	0x00008081
    97ac:	0001ad28 	.word	0x0001ad28

000097b0 <bcm2835_i2c_write_read_rs>:
{
    97b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    97b4:	e1a06001 	mov	r6, r1
    97b8:	e1a05002 	mov	r5, r2
    97bc:	e1a04003 	mov	r4, r3
    U32 ret = *paddr;
    97c0:	e59f3198 	ldr	r3, [pc, #408]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    97c4:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    97c8:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    97cc:	e3822020 	orr	r2, r2, #32
    *paddr = value;
    97d0:	e5832000 	str	r2, [r3]
    *paddr = value;
    97d4:	e5832000 	str	r2, [r3]
    *paddr = value;
    97d8:	e59f2184 	ldr	r2, [pc, #388]	; 9964 <bcm2835_i2c_write_read_rs+0x1b4>
    97dc:	e5832004 	str	r2, [r3, #4]
    97e0:	e5836008 	str	r6, [r3, #8]
    while (remaining && (i < BCM2835_BSC_FIFO_SIZE))
    97e4:	e3560000 	cmp	r6, #0
    97e8:	0a000010 	beq	9830 <bcm2835_i2c_write_read_rs+0x80>
    97ec:	e2402001 	sub	r2, r0, #1
    *paddr = value;
    97f0:	e1a0e003 	mov	lr, r3
        bcm2835_peri_write_nb(fifo, cmds[i]);
    97f4:	e1a03002 	mov	r3, r2
    97f8:	e5f21001 	ldrb	r1, [r2, #1]!
    *paddr = value;
    97fc:	e58e1010 	str	r1, [lr, #16]
    while (remaining && (i < BCM2835_BSC_FIFO_SIZE))
    9800:	e0401002 	sub	r1, r0, r2
    9804:	e2411001 	sub	r1, r1, #1
    9808:	e266c000 	rsb	ip, r6, #0
    980c:	e2833002 	add	r3, r3, #2
    9810:	e0433000 	sub	r3, r3, r0
    9814:	e353000f 	cmp	r3, #15
    9818:	83a03000 	movhi	r3, #0
    981c:	93a03001 	movls	r3, #1
    9820:	e15c0001 	cmp	ip, r1
    9824:	03a03000 	moveq	r3, #0
    9828:	e3530000 	cmp	r3, #0
    982c:	1afffff0 	bne	97f4 <bcm2835_i2c_write_read_rs+0x44>
    *paddr = value;
    9830:	e59f3128 	ldr	r3, [pc, #296]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    9834:	e59f212c 	ldr	r2, [pc, #300]	; 9968 <bcm2835_i2c_write_read_rs+0x1b8>
    9838:	e5832000 	str	r2, [r3]
    return *paddr;
    983c:	e5932004 	ldr	r2, [r3, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_TA))
    9840:	e3120001 	tst	r2, #1
    9844:	1a000003 	bne	9858 <bcm2835_i2c_write_read_rs+0xa8>
    U32 ret = *paddr;
    9848:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    984c:	e5931004 	ldr	r1, [r3, #4]
        if (bcm2835_peri_read(status) & BCM2835_BSC_S_DONE)
    9850:	e3120002 	tst	r2, #2
    9854:	0afffff8 	beq	983c <bcm2835_i2c_write_read_rs+0x8c>
    *paddr = value;
    9858:	e59f7100 	ldr	r7, [pc, #256]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    985c:	e5874008 	str	r4, [r7, #8]
    9860:	e59f3104 	ldr	r3, [pc, #260]	; 996c <bcm2835_i2c_write_read_rs+0x1bc>
    9864:	e5873000 	str	r3, [r7]
    bcm2835_st_delay(bcm2835_st_read(), i2c_byte_wait_us * (cmds_len + 1));
    9868:	ebffff61 	bl	95f4 <bcm2835_st_read>
    986c:	e2866001 	add	r6, r6, #1
    9870:	e59f30f8 	ldr	r3, [pc, #248]	; 9970 <bcm2835_i2c_write_read_rs+0x1c0>
    9874:	e5932000 	ldr	r2, [r3]
    9878:	e0020692 	mul	r2, r2, r6
    987c:	e3a03000 	mov	r3, #0
    9880:	ebffff62 	bl	9610 <bcm2835_st_delay>
    return *paddr;
    9884:	e5971004 	ldr	r1, [r7, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    9888:	e2111002 	ands	r1, r1, #2
    return *paddr;
    988c:	01a00007 	moveq	r0, r7
    9890:	0a000025 	beq	992c <bcm2835_i2c_write_read_rs+0x17c>
    i = 0;
    9894:	e3a01000 	mov	r1, #0
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    9898:	e3540000 	cmp	r4, #0
    989c:	0a000009 	beq	98c8 <bcm2835_i2c_write_read_rs+0x118>
    98a0:	e2411001 	sub	r1, r1, #1
    98a4:	e0855001 	add	r5, r5, r1
    return *paddr;
    98a8:	e59f30b0 	ldr	r3, [pc, #176]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    98ac:	e5932004 	ldr	r2, [r3, #4]
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    98b0:	e3120020 	tst	r2, #32
    98b4:	0a000003 	beq	98c8 <bcm2835_i2c_write_read_rs+0x118>
    return *paddr;
    98b8:	e5932010 	ldr	r2, [r3, #16]
        buf[i] = bcm2835_peri_read_nb(fifo);
    98bc:	e5e52001 	strb	r2, [r5, #1]!
    while (remaining && (bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD))
    98c0:	e2544001 	subs	r4, r4, #1
    98c4:	1afffff8 	bne	98ac <bcm2835_i2c_write_read_rs+0xfc>
    U32 ret = *paddr;
    98c8:	e59f3090 	ldr	r3, [pc, #144]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    98cc:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    98d0:	e5933004 	ldr	r3, [r3, #4]
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    98d4:	e3120c01 	tst	r2, #256	; 0x100
        reason = BCM2835_I2C_REASON_ERROR_NACK;
    98d8:	13a00001 	movne	r0, #1
    if (bcm2835_peri_read(status) & BCM2835_BSC_S_ERR)
    98dc:	1a000008 	bne	9904 <bcm2835_i2c_write_read_rs+0x154>
    U32 ret = *paddr;
    98e0:	e59f3078 	ldr	r3, [pc, #120]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    98e4:	e5932004 	ldr	r2, [r3, #4]
    *paddr; // Read without assigning to an unused variable
    98e8:	e5933004 	ldr	r3, [r3, #4]
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    98ec:	e3120c02 	tst	r2, #512	; 0x200
        reason = BCM2835_I2C_REASON_ERROR_CLKT;
    98f0:	13a00002 	movne	r0, #2
    else if (bcm2835_peri_read(status) & BCM2835_BSC_S_CLKT)
    98f4:	1a000002 	bne	9904 <bcm2835_i2c_write_read_rs+0x154>
    else if (remaining)
    98f8:	e2540000 	subs	r0, r4, #0
    98fc:	13a00001 	movne	r0, #1
    9900:	e1a00100 	lsl	r0, r0, #2
    U32 ret = *paddr;
    9904:	e59f3054 	ldr	r3, [pc, #84]	; 9960 <bcm2835_i2c_write_read_rs+0x1b0>
    9908:	e5932000 	ldr	r2, [r3]
    *paddr; // Read without assigning to an unused variable
    990c:	e5931000 	ldr	r1, [r3]
    v = (v & ~mask) | (value & mask);
    9910:	e3822002 	orr	r2, r2, #2
    *paddr = value;
    9914:	e5832000 	str	r2, [r3]
    *paddr = value;
    9918:	e5832000 	str	r2, [r3]
}
    991c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    return *paddr;
    9920:	e5903004 	ldr	r3, [r0, #4]
    while (!(bcm2835_peri_read_nb(status) & BCM2835_BSC_S_DONE))
    9924:	e3130002 	tst	r3, #2
    9928:	1affffda 	bne	9898 <bcm2835_i2c_write_read_rs+0xe8>
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    992c:	e3540000 	cmp	r4, #0
    9930:	0afffffa 	beq	9920 <bcm2835_i2c_write_read_rs+0x170>
    9934:	e2413001 	sub	r3, r1, #1
    9938:	e0853003 	add	r3, r5, r3
    return *paddr;
    993c:	e5902004 	ldr	r2, [r0, #4]
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    9940:	e3120020 	tst	r2, #32
    9944:	0afffff5 	beq	9920 <bcm2835_i2c_write_read_rs+0x170>
    return *paddr;
    9948:	e5902010 	ldr	r2, [r0, #16]
            buf[i] = bcm2835_peri_read_nb(fifo);
    994c:	e5e32001 	strb	r2, [r3, #1]!
            i++;
    9950:	e2811001 	add	r1, r1, #1
        while (remaining && bcm2835_peri_read_nb(status) & BCM2835_BSC_S_RXD)
    9954:	e2544001 	subs	r4, r4, #1
    9958:	1afffff7 	bne	993c <bcm2835_i2c_write_read_rs+0x18c>
    995c:	eaffffef 	b	9920 <bcm2835_i2c_write_read_rs+0x170>
    9960:	20804000 	.word	0x20804000
    9964:	00000302 	.word	0x00000302
    9968:	00008080 	.word	0x00008080
    996c:	00008081 	.word	0x00008081
    9970:	0001ad28 	.word	0x0001ad28

00009974 <bcm2835_pwm_set_clock>:
    *paddr = value;
    9974:	e59f3040 	ldr	r3, [pc, #64]	; 99bc <bcm2835_pwm_set_clock+0x48>
    9978:	e59f2040 	ldr	r2, [pc, #64]	; 99c0 <bcm2835_pwm_set_clock+0x4c>
    997c:	e58320a0 	str	r2, [r3, #160]	; 0xa0
    *paddr = value;
    9980:	e58320a0 	str	r2, [r3, #160]	; 0xa0
    U32 ret = *paddr;
    9984:	e59320a0 	ldr	r2, [r3, #160]	; 0xa0
    *paddr; // Read without assigning to an unused variable
    9988:	e59310a0 	ldr	r1, [r3, #160]	; 0xa0

    // Stop PWM clock
    bcm2835_peri_write(((U32*)BCM2835_CLOCK_BASE) + BCM2835_PWMCLK_CNTL, BCM2835_PWM_PASSWRD | 0x01);

    // Wait for the clock to be not busy
    while ((bcm2835_peri_read(((U32*)BCM2835_CLOCK_BASE) + BCM2835_PWMCLK_CNTL) & 0x80) != 0);
    998c:	e3120080 	tst	r2, #128	; 0x80
    9990:	1afffffb 	bne	9984 <bcm2835_pwm_set_clock+0x10>

    // set the clock divider and enable PWM clock
    bcm2835_peri_write(((U32*)BCM2835_CLOCK_BASE) + BCM2835_PWMCLK_DIV, BCM2835_PWM_PASSWRD | (divisor << 12));
    9994:	e59f3028 	ldr	r3, [pc, #40]	; 99c4 <bcm2835_pwm_set_clock+0x50>
    9998:	e0033600 	and	r3, r3, r0, lsl #12
    999c:	e383345a 	orr	r3, r3, #1509949440	; 0x5a000000
    *paddr = value;
    99a0:	e59f2014 	ldr	r2, [pc, #20]	; 99bc <bcm2835_pwm_set_clock+0x48>
    99a4:	e58230a4 	str	r3, [r2, #164]	; 0xa4
    *paddr = value;
    99a8:	e58230a4 	str	r3, [r2, #164]	; 0xa4
    *paddr = value;
    99ac:	e59f3014 	ldr	r3, [pc, #20]	; 99c8 <bcm2835_pwm_set_clock+0x54>
    99b0:	e58230a0 	str	r3, [r2, #160]	; 0xa0
    *paddr = value;
    99b4:	e58230a0 	str	r3, [r2, #160]	; 0xa0
    bcm2835_peri_write(((U32*)BCM2835_CLOCK_BASE) + BCM2835_PWMCLK_CNTL, BCM2835_PWM_PASSWRD | 0x11); // Source=osc and enable
}
    99b8:	e12fff1e 	bx	lr
    99bc:	20101000 	.word	0x20101000
    99c0:	5a000001 	.word	0x5a000001
    99c4:	00fff000 	.word	0x00fff000
    99c8:	5a000011 	.word	0x5a000011

000099cc <bcm2835_pwm_set_mode>:
    U32 ret = *paddr;
    99cc:	e59fc054 	ldr	ip, [pc, #84]	; 9a28 <bcm2835_pwm_set_mode+0x5c>
    99d0:	e59c3000 	ldr	r3, [ip]
    *paddr; // Read without assigning to an unused variable
    99d4:	e59cc000 	ldr	ip, [ip]

void bcm2835_pwm_set_mode(U8 channel, U8 markspace, U8 enabled)
{
    U32 control = bcm2835_peri_read((U32*)BCM2835_GPIO_PWM + BCM2835_PWM_CONTROL);

    if (channel == 0)
    99d8:	e3500000 	cmp	r0, #0
    99dc:	1a000008 	bne	9a04 <bcm2835_pwm_set_mode+0x38>
    {
        if (markspace)
    99e0:	e3510000 	cmp	r1, #0
            control |= BCM2835_PWM0_MS_MODE;
    99e4:	13833080 	orrne	r3, r3, #128	; 0x80
        else
            control &= ~BCM2835_PWM0_MS_MODE;
    99e8:	03c33080 	biceq	r3, r3, #128	; 0x80
        if (enabled)
    99ec:	e3520000 	cmp	r2, #0
            control |= BCM2835_PWM0_ENABLE;
    99f0:	13833001 	orrne	r3, r3, #1
        else
            control &= ~BCM2835_PWM0_ENABLE;
    99f4:	03c33001 	biceq	r3, r3, #1
    *paddr = value;
    99f8:	e59f2028 	ldr	r2, [pc, #40]	; 9a28 <bcm2835_pwm_set_mode+0x5c>
    99fc:	e5823000 	str	r3, [r2]

    // If you use the barrier here, weird things happen, and the commands don't work
    bcm2835_peri_write_nb((U32*)BCM2835_GPIO_PWM + BCM2835_PWM_CONTROL, control);
    //  bcm2835_peri_write_nb(bcm2835_pwm + BCM2835_PWM_CONTROL, BCM2835_PWM0_ENABLE | BCM2835_PWM1_ENABLE | BCM2835_PWM0_MS_MODE | BCM2835_PWM1_MS_MODE);

}
    9a00:	e12fff1e 	bx	lr
    else if (channel == 1)
    9a04:	e3500001 	cmp	r0, #1
    9a08:	1afffffa 	bne	99f8 <bcm2835_pwm_set_mode+0x2c>
        if (markspace)
    9a0c:	e3510000 	cmp	r1, #0
            control |= BCM2835_PWM1_MS_MODE;
    9a10:	13833902 	orrne	r3, r3, #32768	; 0x8000
            control &= ~BCM2835_PWM1_MS_MODE;
    9a14:	03c33902 	biceq	r3, r3, #32768	; 0x8000
        if (enabled)
    9a18:	e3520000 	cmp	r2, #0
            control |= BCM2835_PWM1_ENABLE;
    9a1c:	13833c01 	orrne	r3, r3, #256	; 0x100
            control &= ~BCM2835_PWM1_ENABLE;
    9a20:	03c33c01 	biceq	r3, r3, #256	; 0x100
    9a24:	eafffff3 	b	99f8 <bcm2835_pwm_set_mode+0x2c>
    9a28:	2020c000 	.word	0x2020c000

00009a2c <bcm2835_pwm_set_range>:

void bcm2835_pwm_set_range(U8 channel, U32 range)
{
    if (channel == 0)
    9a2c:	e3500000 	cmp	r0, #0
    9a30:	0a000003 	beq	9a44 <bcm2835_pwm_set_range+0x18>
        bcm2835_peri_write_nb((U32*)BCM2835_GPIO_PWM + BCM2835_PWM0_RANGE, range);
    else if (channel == 1)
    9a34:	e3500001 	cmp	r0, #1
    *paddr = value;
    9a38:	059f3010 	ldreq	r3, [pc, #16]	; 9a50 <bcm2835_pwm_set_range+0x24>
    9a3c:	05831020 	streq	r1, [r3, #32]
        bcm2835_peri_write_nb((U32*)BCM2835_GPIO_PWM + BCM2835_PWM1_RANGE, range);
}
    9a40:	e12fff1e 	bx	lr
    *paddr = value;
    9a44:	e59f3004 	ldr	r3, [pc, #4]	; 9a50 <bcm2835_pwm_set_range+0x24>
    9a48:	e5831010 	str	r1, [r3, #16]
}
    9a4c:	e12fff1e 	bx	lr
    9a50:	2020c000 	.word	0x2020c000

00009a54 <bcm2835_pwm_set_data>:

void bcm2835_pwm_set_data(U8 channel, U32 data)
{
    if (channel == 0)
    9a54:	e3500000 	cmp	r0, #0
    9a58:	0a000003 	beq	9a6c <bcm2835_pwm_set_data+0x18>
        bcm2835_peri_write_nb((U32*)BCM2835_GPIO_PWM + BCM2835_PWM0_DATA, data);
    else if (channel == 1)
    9a5c:	e3500001 	cmp	r0, #1
    *paddr = value;
    9a60:	059f3010 	ldreq	r3, [pc, #16]	; 9a78 <bcm2835_pwm_set_data+0x24>
    9a64:	05831024 	streq	r1, [r3, #36]	; 0x24
        bcm2835_peri_write_nb((U32*)BCM2835_GPIO_PWM + BCM2835_PWM1_DATA, data);
}
    9a68:	e12fff1e 	bx	lr
    *paddr = value;
    9a6c:	e59f3004 	ldr	r3, [pc, #4]	; 9a78 <bcm2835_pwm_set_data+0x24>
    9a70:	e5831014 	str	r1, [r3, #20]
}
    9a74:	e12fff1e 	bx	lr
    9a78:	2020c000 	.word	0x2020c000
    9a7c:	e3a0c0ff 	mov	ip, #255	; 0xff
    9a80:	e01c2ba0 	ands	r2, ip, r0, lsr #23
    9a84:	101c3ba1 	andsne	r3, ip, r1, lsr #23
    9a88:	1132000c 	teqne	r2, ip
    9a8c:	1133000c 	teqne	r3, ip
    9a90:	0a00003e 	beq	9b90 <bcm2835_pwm_set_data+0x13c>
    9a94:	e0822003 	add	r2, r2, r3
    9a98:	e020c001 	eor	ip, r0, r1
    9a9c:	e1b00480 	lsls	r0, r0, #9
    9aa0:	11b01481 	lslsne	r1, r1, #9
    9aa4:	0a000010 	beq	9aec <bcm2835_pwm_set_data+0x98>
    9aa8:	e3a03302 	mov	r3, #134217728	; 0x8000000
    9aac:	e18302a0 	orr	r0, r3, r0, lsr #5
    9ab0:	e18312a1 	orr	r1, r3, r1, lsr #5
    9ab4:	e0813190 	umull	r3, r1, r0, r1
    9ab8:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
    9abc:	e3510502 	cmp	r1, #8388608	; 0x800000
    9ac0:	31a01081 	lslcc	r1, r1, #1
    9ac4:	31811fa3 	orrcc	r1, r1, r3, lsr #31
    9ac8:	31a03083 	lslcc	r3, r3, #1
    9acc:	e1800001 	orr	r0, r0, r1
    9ad0:	e2c2207f 	sbc	r2, r2, #127	; 0x7f
    9ad4:	e35200fd 	cmp	r2, #253	; 0xfd
    9ad8:	8a00000f 	bhi	9b1c <bcm2835_pwm_set_data+0xc8>
    9adc:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
    9ae0:	e0a00b82 	adc	r0, r0, r2, lsl #23
    9ae4:	03c00001 	biceq	r0, r0, #1
    9ae8:	e12fff1e 	bx	lr
    9aec:	e3300000 	teq	r0, #0
    9af0:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
    9af4:	01a01481 	lsleq	r1, r1, #9
    9af8:	e18c04a0 	orr	r0, ip, r0, lsr #9
    9afc:	e18004a1 	orr	r0, r0, r1, lsr #9
    9b00:	e252207f 	subs	r2, r2, #127	; 0x7f
    9b04:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
    9b08:	c1800b82 	orrgt	r0, r0, r2, lsl #23
    9b0c:	c12fff1e 	bxgt	lr
    9b10:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    9b14:	e3a03000 	mov	r3, #0
    9b18:	e2522001 	subs	r2, r2, #1
    9b1c:	ca000035 	bgt	9bf8 <bcm2835_pwm_set_data+0x1a4>
    9b20:	e3720019 	cmn	r2, #25
    9b24:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
    9b28:	d12fff1e 	bxle	lr
    9b2c:	e2622000 	rsb	r2, r2, #0
    9b30:	e1b01080 	lsls	r1, r0, #1
    9b34:	e1a01231 	lsr	r1, r1, r2
    9b38:	e2622020 	rsb	r2, r2, #32
    9b3c:	e1a0c210 	lsl	ip, r0, r2
    9b40:	e1b00061 	rrxs	r0, r1
    9b44:	e2a00000 	adc	r0, r0, #0
    9b48:	e193308c 	orrs	r3, r3, ip, lsl #1
    9b4c:	01c00fac 	biceq	r0, r0, ip, lsr #31
    9b50:	e12fff1e 	bx	lr
    9b54:	e3320000 	teq	r2, #0
    9b58:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
    9b5c:	01a00080 	lsleq	r0, r0, #1
    9b60:	03100502 	tsteq	r0, #8388608	; 0x800000
    9b64:	02422001 	subeq	r2, r2, #1
    9b68:	0afffffb 	beq	9b5c <bcm2835_pwm_set_data+0x108>
    9b6c:	e180000c 	orr	r0, r0, ip
    9b70:	e3330000 	teq	r3, #0
    9b74:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
    9b78:	01a01081 	lsleq	r1, r1, #1
    9b7c:	03110502 	tsteq	r1, #8388608	; 0x800000
    9b80:	02433001 	subeq	r3, r3, #1
    9b84:	0afffffb 	beq	9b78 <bcm2835_pwm_set_data+0x124>
    9b88:	e181100c 	orr	r1, r1, ip
    9b8c:	eaffffc0 	b	9a94 <bcm2835_pwm_set_data+0x40>
    9b90:	e00c3ba1 	and	r3, ip, r1, lsr #23
    9b94:	e132000c 	teq	r2, ip
    9b98:	1133000c 	teqne	r3, ip
    9b9c:	0a000005 	beq	9bb8 <bcm2835_pwm_set_data+0x164>
    9ba0:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
    9ba4:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
    9ba8:	1affffe9 	bne	9b54 <bcm2835_pwm_set_data+0x100>
    9bac:	e0200001 	eor	r0, r0, r1
    9bb0:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    9bb4:	e12fff1e 	bx	lr
    9bb8:	e3300000 	teq	r0, #0
    9bbc:	13300102 	teqne	r0, #-2147483648	; 0x80000000
    9bc0:	01a00001 	moveq	r0, r1
    9bc4:	13310000 	teqne	r1, #0
    9bc8:	13310102 	teqne	r1, #-2147483648	; 0x80000000
    9bcc:	0a00000d 	beq	9c08 <bcm2835_pwm_set_data+0x1b4>
    9bd0:	e132000c 	teq	r2, ip
    9bd4:	1a000001 	bne	9be0 <bcm2835_pwm_set_data+0x18c>
    9bd8:	e1b02480 	lsls	r2, r0, #9
    9bdc:	1a000009 	bne	9c08 <bcm2835_pwm_set_data+0x1b4>
    9be0:	e133000c 	teq	r3, ip
    9be4:	1a000002 	bne	9bf4 <bcm2835_pwm_set_data+0x1a0>
    9be8:	e1b03481 	lsls	r3, r1, #9
    9bec:	11a00001 	movne	r0, r1
    9bf0:	1a000004 	bne	9c08 <bcm2835_pwm_set_data+0x1b4>
    9bf4:	e0200001 	eor	r0, r0, r1
    9bf8:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    9bfc:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    9c00:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    9c04:	e12fff1e 	bx	lr
    9c08:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    9c0c:	e3800503 	orr	r0, r0, #12582912	; 0xc00000
    9c10:	e12fff1e 	bx	lr

00009c14 <__udivsi3>:
    9c14:	e2512001 	subs	r2, r1, #1
    9c18:	012fff1e 	bxeq	lr
    9c1c:	3a000036 	bcc	9cfc <__udivsi3+0xe8>
    9c20:	e1500001 	cmp	r0, r1
    9c24:	9a000022 	bls	9cb4 <__udivsi3+0xa0>
    9c28:	e1110002 	tst	r1, r2
    9c2c:	0a000023 	beq	9cc0 <__udivsi3+0xac>
    9c30:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    9c34:	01a01181 	lsleq	r1, r1, #3
    9c38:	03a03008 	moveq	r3, #8
    9c3c:	13a03001 	movne	r3, #1
    9c40:	e3510201 	cmp	r1, #268435456	; 0x10000000
    9c44:	31510000 	cmpcc	r1, r0
    9c48:	31a01201 	lslcc	r1, r1, #4
    9c4c:	31a03203 	lslcc	r3, r3, #4
    9c50:	3afffffa 	bcc	9c40 <__udivsi3+0x2c>
    9c54:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    9c58:	31510000 	cmpcc	r1, r0
    9c5c:	31a01081 	lslcc	r1, r1, #1
    9c60:	31a03083 	lslcc	r3, r3, #1
    9c64:	3afffffa 	bcc	9c54 <__udivsi3+0x40>
    9c68:	e3a02000 	mov	r2, #0
    9c6c:	e1500001 	cmp	r0, r1
    9c70:	20400001 	subcs	r0, r0, r1
    9c74:	21822003 	orrcs	r2, r2, r3
    9c78:	e15000a1 	cmp	r0, r1, lsr #1
    9c7c:	204000a1 	subcs	r0, r0, r1, lsr #1
    9c80:	218220a3 	orrcs	r2, r2, r3, lsr #1
    9c84:	e1500121 	cmp	r0, r1, lsr #2
    9c88:	20400121 	subcs	r0, r0, r1, lsr #2
    9c8c:	21822123 	orrcs	r2, r2, r3, lsr #2
    9c90:	e15001a1 	cmp	r0, r1, lsr #3
    9c94:	204001a1 	subcs	r0, r0, r1, lsr #3
    9c98:	218221a3 	orrcs	r2, r2, r3, lsr #3
    9c9c:	e3500000 	cmp	r0, #0
    9ca0:	11b03223 	lsrsne	r3, r3, #4
    9ca4:	11a01221 	lsrne	r1, r1, #4
    9ca8:	1affffef 	bne	9c6c <__udivsi3+0x58>
    9cac:	e1a00002 	mov	r0, r2
    9cb0:	e12fff1e 	bx	lr
    9cb4:	03a00001 	moveq	r0, #1
    9cb8:	13a00000 	movne	r0, #0
    9cbc:	e12fff1e 	bx	lr
    9cc0:	e3510801 	cmp	r1, #65536	; 0x10000
    9cc4:	21a01821 	lsrcs	r1, r1, #16
    9cc8:	23a02010 	movcs	r2, #16
    9ccc:	33a02000 	movcc	r2, #0
    9cd0:	e3510c01 	cmp	r1, #256	; 0x100
    9cd4:	21a01421 	lsrcs	r1, r1, #8
    9cd8:	22822008 	addcs	r2, r2, #8
    9cdc:	e3510010 	cmp	r1, #16
    9ce0:	21a01221 	lsrcs	r1, r1, #4
    9ce4:	22822004 	addcs	r2, r2, #4
    9ce8:	e3510004 	cmp	r1, #4
    9cec:	82822003 	addhi	r2, r2, #3
    9cf0:	908220a1 	addls	r2, r2, r1, lsr #1
    9cf4:	e1a00230 	lsr	r0, r0, r2
    9cf8:	e12fff1e 	bx	lr
    9cfc:	e3500000 	cmp	r0, #0
    9d00:	13e00000 	mvnne	r0, #0
    9d04:	ea000007 	b	9d28 <__aeabi_idiv0>

00009d08 <__aeabi_uidivmod>:
    9d08:	e3510000 	cmp	r1, #0
    9d0c:	0afffffa 	beq	9cfc <__udivsi3+0xe8>
    9d10:	e92d4003 	push	{r0, r1, lr}
    9d14:	ebffffbe 	bl	9c14 <__udivsi3>
    9d18:	e8bd4006 	pop	{r1, r2, lr}
    9d1c:	e0030092 	mul	r3, r2, r0
    9d20:	e0411003 	sub	r1, r1, r3
    9d24:	e12fff1e 	bx	lr

00009d28 <__aeabi_idiv0>:
    9d28:	e12fff1e 	bx	lr

00009d2c <__aeabi_dmul>:
    9d2c:	e92d4070 	push	{r4, r5, r6, lr}
    9d30:	e3a0c0ff 	mov	ip, #255	; 0xff
    9d34:	e38ccc07 	orr	ip, ip, #1792	; 0x700
    9d38:	e01c4a21 	ands	r4, ip, r1, lsr #20
    9d3c:	101c5a23 	andsne	r5, ip, r3, lsr #20
    9d40:	1134000c 	teqne	r4, ip
    9d44:	1135000c 	teqne	r5, ip
    9d48:	0b000075 	bleq	9f24 <__aeabi_dmul+0x1f8>
    9d4c:	e0844005 	add	r4, r4, r5
    9d50:	e0216003 	eor	r6, r1, r3
    9d54:	e1c11a8c 	bic	r1, r1, ip, lsl #21
    9d58:	e1c33a8c 	bic	r3, r3, ip, lsl #21
    9d5c:	e1905601 	orrs	r5, r0, r1, lsl #12
    9d60:	11925603 	orrsne	r5, r2, r3, lsl #12
    9d64:	e3811601 	orr	r1, r1, #1048576	; 0x100000
    9d68:	e3833601 	orr	r3, r3, #1048576	; 0x100000
    9d6c:	0a00001d 	beq	9de8 <__aeabi_dmul+0xbc>
    9d70:	e08ec290 	umull	ip, lr, r0, r2
    9d74:	e3a05000 	mov	r5, #0
    9d78:	e0a5e291 	umlal	lr, r5, r1, r2
    9d7c:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
    9d80:	e0a5e390 	umlal	lr, r5, r0, r3
    9d84:	e3a06000 	mov	r6, #0
    9d88:	e0a65391 	umlal	r5, r6, r1, r3
    9d8c:	e33c0000 	teq	ip, #0
    9d90:	138ee001 	orrne	lr, lr, #1
    9d94:	e24440ff 	sub	r4, r4, #255	; 0xff
    9d98:	e3560c02 	cmp	r6, #512	; 0x200
    9d9c:	e2c44c03 	sbc	r4, r4, #768	; 0x300
    9da0:	2a000002 	bcs	9db0 <__aeabi_dmul+0x84>
    9da4:	e1b0e08e 	lsls	lr, lr, #1
    9da8:	e0b55005 	adcs	r5, r5, r5
    9dac:	e0a66006 	adc	r6, r6, r6
    9db0:	e1821586 	orr	r1, r2, r6, lsl #11
    9db4:	e1811aa5 	orr	r1, r1, r5, lsr #21
    9db8:	e1a00585 	lsl	r0, r5, #11
    9dbc:	e1800aae 	orr	r0, r0, lr, lsr #21
    9dc0:	e1a0e58e 	lsl	lr, lr, #11
    9dc4:	e254c0fd 	subs	ip, r4, #253	; 0xfd
    9dc8:	835c0c07 	cmphi	ip, #1792	; 0x700
    9dcc:	8a000011 	bhi	9e18 <__aeabi_dmul+0xec>
    9dd0:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
    9dd4:	01b0e0a0 	lsrseq	lr, r0, #1
    9dd8:	e2b00000 	adcs	r0, r0, #0
    9ddc:	e0a11a04 	adc	r1, r1, r4, lsl #20
    9de0:	e8bd4070 	pop	{r4, r5, r6, lr}
    9de4:	e12fff1e 	bx	lr
    9de8:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
    9dec:	e1861001 	orr	r1, r6, r1
    9df0:	e1800002 	orr	r0, r0, r2
    9df4:	e0211003 	eor	r1, r1, r3
    9df8:	e05440ac 	subs	r4, r4, ip, lsr #1
    9dfc:	c074500c 	rsbsgt	r5, r4, ip
    9e00:	c1811a04 	orrgt	r1, r1, r4, lsl #20
    9e04:	c8bd4070 	popgt	{r4, r5, r6, lr}
    9e08:	c12fff1e 	bxgt	lr
    9e0c:	e3811601 	orr	r1, r1, #1048576	; 0x100000
    9e10:	e3a0e000 	mov	lr, #0
    9e14:	e2544001 	subs	r4, r4, #1
    9e18:	ca00005d 	bgt	9f94 <__aeabi_dmul+0x268>
    9e1c:	e3740036 	cmn	r4, #54	; 0x36
    9e20:	d3a00000 	movle	r0, #0
    9e24:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
    9e28:	d8bd4070 	pople	{r4, r5, r6, lr}
    9e2c:	d12fff1e 	bxle	lr
    9e30:	e2644000 	rsb	r4, r4, #0
    9e34:	e2544020 	subs	r4, r4, #32
    9e38:	aa00001a 	bge	9ea8 <__aeabi_dmul+0x17c>
    9e3c:	e294400c 	adds	r4, r4, #12
    9e40:	ca00000c 	bgt	9e78 <__aeabi_dmul+0x14c>
    9e44:	e2844014 	add	r4, r4, #20
    9e48:	e2645020 	rsb	r5, r4, #32
    9e4c:	e1a03510 	lsl	r3, r0, r5
    9e50:	e1a00430 	lsr	r0, r0, r4
    9e54:	e1800511 	orr	r0, r0, r1, lsl r5
    9e58:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
    9e5c:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
    9e60:	e0900fa3 	adds	r0, r0, r3, lsr #31
    9e64:	e0a21431 	adc	r1, r2, r1, lsr r4
    9e68:	e19ee083 	orrs	lr, lr, r3, lsl #1
    9e6c:	01c00fa3 	biceq	r0, r0, r3, lsr #31
    9e70:	e8bd4070 	pop	{r4, r5, r6, lr}
    9e74:	e12fff1e 	bx	lr
    9e78:	e264400c 	rsb	r4, r4, #12
    9e7c:	e2645020 	rsb	r5, r4, #32
    9e80:	e1a03410 	lsl	r3, r0, r4
    9e84:	e1a00530 	lsr	r0, r0, r5
    9e88:	e1800411 	orr	r0, r0, r1, lsl r4
    9e8c:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
    9e90:	e0900fa3 	adds	r0, r0, r3, lsr #31
    9e94:	e2a11000 	adc	r1, r1, #0
    9e98:	e19ee083 	orrs	lr, lr, r3, lsl #1
    9e9c:	01c00fa3 	biceq	r0, r0, r3, lsr #31
    9ea0:	e8bd4070 	pop	{r4, r5, r6, lr}
    9ea4:	e12fff1e 	bx	lr
    9ea8:	e2645020 	rsb	r5, r4, #32
    9eac:	e18ee510 	orr	lr, lr, r0, lsl r5
    9eb0:	e1a03430 	lsr	r3, r0, r4
    9eb4:	e1833511 	orr	r3, r3, r1, lsl r5
    9eb8:	e1a00431 	lsr	r0, r1, r4
    9ebc:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
    9ec0:	e1c00431 	bic	r0, r0, r1, lsr r4
    9ec4:	e0800fa3 	add	r0, r0, r3, lsr #31
    9ec8:	e19ee083 	orrs	lr, lr, r3, lsl #1
    9ecc:	01c00fa3 	biceq	r0, r0, r3, lsr #31
    9ed0:	e8bd4070 	pop	{r4, r5, r6, lr}
    9ed4:	e12fff1e 	bx	lr
    9ed8:	e3340000 	teq	r4, #0
    9edc:	1a000008 	bne	9f04 <__aeabi_dmul+0x1d8>
    9ee0:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
    9ee4:	e1b00080 	lsls	r0, r0, #1
    9ee8:	e0a11001 	adc	r1, r1, r1
    9eec:	e3110601 	tst	r1, #1048576	; 0x100000
    9ef0:	02444001 	subeq	r4, r4, #1
    9ef4:	0afffffa 	beq	9ee4 <__aeabi_dmul+0x1b8>
    9ef8:	e1811006 	orr	r1, r1, r6
    9efc:	e3350000 	teq	r5, #0
    9f00:	112fff1e 	bxne	lr
    9f04:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
    9f08:	e1b02082 	lsls	r2, r2, #1
    9f0c:	e0a33003 	adc	r3, r3, r3
    9f10:	e3130601 	tst	r3, #1048576	; 0x100000
    9f14:	02455001 	subeq	r5, r5, #1
    9f18:	0afffffa 	beq	9f08 <__aeabi_dmul+0x1dc>
    9f1c:	e1833006 	orr	r3, r3, r6
    9f20:	e12fff1e 	bx	lr
    9f24:	e134000c 	teq	r4, ip
    9f28:	e00c5a23 	and	r5, ip, r3, lsr #20
    9f2c:	1135000c 	teqne	r5, ip
    9f30:	0a000007 	beq	9f54 <__aeabi_dmul+0x228>
    9f34:	e1906081 	orrs	r6, r0, r1, lsl #1
    9f38:	11926083 	orrsne	r6, r2, r3, lsl #1
    9f3c:	1affffe5 	bne	9ed8 <__aeabi_dmul+0x1ac>
    9f40:	e0211003 	eor	r1, r1, r3
    9f44:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
    9f48:	e3a00000 	mov	r0, #0
    9f4c:	e8bd4070 	pop	{r4, r5, r6, lr}
    9f50:	e12fff1e 	bx	lr
    9f54:	e1906081 	orrs	r6, r0, r1, lsl #1
    9f58:	01a00002 	moveq	r0, r2
    9f5c:	01a01003 	moveq	r1, r3
    9f60:	11926083 	orrsne	r6, r2, r3, lsl #1
    9f64:	0a000010 	beq	9fac <__aeabi_dmul+0x280>
    9f68:	e134000c 	teq	r4, ip
    9f6c:	1a000001 	bne	9f78 <__aeabi_dmul+0x24c>
    9f70:	e1906601 	orrs	r6, r0, r1, lsl #12
    9f74:	1a00000c 	bne	9fac <__aeabi_dmul+0x280>
    9f78:	e135000c 	teq	r5, ip
    9f7c:	1a000003 	bne	9f90 <__aeabi_dmul+0x264>
    9f80:	e1926603 	orrs	r6, r2, r3, lsl #12
    9f84:	11a00002 	movne	r0, r2
    9f88:	11a01003 	movne	r1, r3
    9f8c:	1a000006 	bne	9fac <__aeabi_dmul+0x280>
    9f90:	e0211003 	eor	r1, r1, r3
    9f94:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
    9f98:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
    9f9c:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
    9fa0:	e3a00000 	mov	r0, #0
    9fa4:	e8bd4070 	pop	{r4, r5, r6, lr}
    9fa8:	e12fff1e 	bx	lr
    9fac:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
    9fb0:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
    9fb4:	e8bd4070 	pop	{r4, r5, r6, lr}
    9fb8:	e12fff1e 	bx	lr

00009fbc <__aeabi_ddiv>:
    9fbc:	e92d4070 	push	{r4, r5, r6, lr}
    9fc0:	e3a0c0ff 	mov	ip, #255	; 0xff
    9fc4:	e38ccc07 	orr	ip, ip, #1792	; 0x700
    9fc8:	e01c4a21 	ands	r4, ip, r1, lsr #20
    9fcc:	101c5a23 	andsne	r5, ip, r3, lsr #20
    9fd0:	1134000c 	teqne	r4, ip
    9fd4:	1135000c 	teqne	r5, ip
    9fd8:	0b00005e 	bleq	a158 <__aeabi_ddiv+0x19c>
    9fdc:	e0444005 	sub	r4, r4, r5
    9fe0:	e021e003 	eor	lr, r1, r3
    9fe4:	e1925603 	orrs	r5, r2, r3, lsl #12
    9fe8:	e1a01601 	lsl	r1, r1, #12
    9fec:	0a00004c 	beq	a124 <__aeabi_ddiv+0x168>
    9ff0:	e1a03603 	lsl	r3, r3, #12
    9ff4:	e3a05201 	mov	r5, #268435456	; 0x10000000
    9ff8:	e1853223 	orr	r3, r5, r3, lsr #4
    9ffc:	e1833c22 	orr	r3, r3, r2, lsr #24
    a000:	e1a02402 	lsl	r2, r2, #8
    a004:	e1855221 	orr	r5, r5, r1, lsr #4
    a008:	e1855c20 	orr	r5, r5, r0, lsr #24
    a00c:	e1a06400 	lsl	r6, r0, #8
    a010:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
    a014:	e1550003 	cmp	r5, r3
    a018:	01560002 	cmpeq	r6, r2
    a01c:	e2a440fd 	adc	r4, r4, #253	; 0xfd
    a020:	e2844c03 	add	r4, r4, #768	; 0x300
    a024:	2a000001 	bcs	a030 <__aeabi_ddiv+0x74>
    a028:	e1b030a3 	lsrs	r3, r3, #1
    a02c:	e1a02062 	rrx	r2, r2
    a030:	e0566002 	subs	r6, r6, r2
    a034:	e0c55003 	sbc	r5, r5, r3
    a038:	e1b030a3 	lsrs	r3, r3, #1
    a03c:	e1a02062 	rrx	r2, r2
    a040:	e3a00601 	mov	r0, #1048576	; 0x100000
    a044:	e3a0c702 	mov	ip, #524288	; 0x80000
    a048:	e056e002 	subs	lr, r6, r2
    a04c:	e0d5e003 	sbcs	lr, r5, r3
    a050:	20466002 	subcs	r6, r6, r2
    a054:	21a0500e 	movcs	r5, lr
    a058:	2180000c 	orrcs	r0, r0, ip
    a05c:	e1b030a3 	lsrs	r3, r3, #1
    a060:	e1a02062 	rrx	r2, r2
    a064:	e056e002 	subs	lr, r6, r2
    a068:	e0d5e003 	sbcs	lr, r5, r3
    a06c:	20466002 	subcs	r6, r6, r2
    a070:	21a0500e 	movcs	r5, lr
    a074:	218000ac 	orrcs	r0, r0, ip, lsr #1
    a078:	e1b030a3 	lsrs	r3, r3, #1
    a07c:	e1a02062 	rrx	r2, r2
    a080:	e056e002 	subs	lr, r6, r2
    a084:	e0d5e003 	sbcs	lr, r5, r3
    a088:	20466002 	subcs	r6, r6, r2
    a08c:	21a0500e 	movcs	r5, lr
    a090:	2180012c 	orrcs	r0, r0, ip, lsr #2
    a094:	e1b030a3 	lsrs	r3, r3, #1
    a098:	e1a02062 	rrx	r2, r2
    a09c:	e056e002 	subs	lr, r6, r2
    a0a0:	e0d5e003 	sbcs	lr, r5, r3
    a0a4:	20466002 	subcs	r6, r6, r2
    a0a8:	21a0500e 	movcs	r5, lr
    a0ac:	218001ac 	orrcs	r0, r0, ip, lsr #3
    a0b0:	e195e006 	orrs	lr, r5, r6
    a0b4:	0a00000d 	beq	a0f0 <__aeabi_ddiv+0x134>
    a0b8:	e1a05205 	lsl	r5, r5, #4
    a0bc:	e1855e26 	orr	r5, r5, r6, lsr #28
    a0c0:	e1a06206 	lsl	r6, r6, #4
    a0c4:	e1a03183 	lsl	r3, r3, #3
    a0c8:	e1833ea2 	orr	r3, r3, r2, lsr #29
    a0cc:	e1a02182 	lsl	r2, r2, #3
    a0d0:	e1b0c22c 	lsrs	ip, ip, #4
    a0d4:	1affffdb 	bne	a048 <__aeabi_ddiv+0x8c>
    a0d8:	e3110601 	tst	r1, #1048576	; 0x100000
    a0dc:	1a000006 	bne	a0fc <__aeabi_ddiv+0x140>
    a0e0:	e1811000 	orr	r1, r1, r0
    a0e4:	e3a00000 	mov	r0, #0
    a0e8:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
    a0ec:	eaffffd5 	b	a048 <__aeabi_ddiv+0x8c>
    a0f0:	e3110601 	tst	r1, #1048576	; 0x100000
    a0f4:	01811000 	orreq	r1, r1, r0
    a0f8:	03a00000 	moveq	r0, #0
    a0fc:	e254c0fd 	subs	ip, r4, #253	; 0xfd
    a100:	835c0c07 	cmphi	ip, #1792	; 0x700
    a104:	8affff43 	bhi	9e18 <__aeabi_dmul+0xec>
    a108:	e055c003 	subs	ip, r5, r3
    a10c:	0056c002 	subseq	ip, r6, r2
    a110:	01b0c0a0 	lsrseq	ip, r0, #1
    a114:	e2b00000 	adcs	r0, r0, #0
    a118:	e0a11a04 	adc	r1, r1, r4, lsl #20
    a11c:	e8bd4070 	pop	{r4, r5, r6, lr}
    a120:	e12fff1e 	bx	lr
    a124:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
    a128:	e18e1621 	orr	r1, lr, r1, lsr #12
    a12c:	e09440ac 	adds	r4, r4, ip, lsr #1
    a130:	c074500c 	rsbsgt	r5, r4, ip
    a134:	c1811a04 	orrgt	r1, r1, r4, lsl #20
    a138:	c8bd4070 	popgt	{r4, r5, r6, lr}
    a13c:	c12fff1e 	bxgt	lr
    a140:	e3811601 	orr	r1, r1, #1048576	; 0x100000
    a144:	e3a0e000 	mov	lr, #0
    a148:	e2544001 	subs	r4, r4, #1
    a14c:	eaffff31 	b	9e18 <__aeabi_dmul+0xec>
    a150:	e185e006 	orr	lr, r5, r6
    a154:	eaffff2f 	b	9e18 <__aeabi_dmul+0xec>
    a158:	e00c5a23 	and	r5, ip, r3, lsr #20
    a15c:	e134000c 	teq	r4, ip
    a160:	0135000c 	teqeq	r5, ip
    a164:	0affff90 	beq	9fac <__aeabi_dmul+0x280>
    a168:	e134000c 	teq	r4, ip
    a16c:	1a000006 	bne	a18c <__aeabi_ddiv+0x1d0>
    a170:	e1904601 	orrs	r4, r0, r1, lsl #12
    a174:	1affff8c 	bne	9fac <__aeabi_dmul+0x280>
    a178:	e135000c 	teq	r5, ip
    a17c:	1affff83 	bne	9f90 <__aeabi_dmul+0x264>
    a180:	e1a00002 	mov	r0, r2
    a184:	e1a01003 	mov	r1, r3
    a188:	eaffff87 	b	9fac <__aeabi_dmul+0x280>
    a18c:	e135000c 	teq	r5, ip
    a190:	1a000004 	bne	a1a8 <__aeabi_ddiv+0x1ec>
    a194:	e1925603 	orrs	r5, r2, r3, lsl #12
    a198:	0affff68 	beq	9f40 <__aeabi_dmul+0x214>
    a19c:	e1a00002 	mov	r0, r2
    a1a0:	e1a01003 	mov	r1, r3
    a1a4:	eaffff80 	b	9fac <__aeabi_dmul+0x280>
    a1a8:	e1906081 	orrs	r6, r0, r1, lsl #1
    a1ac:	11926083 	orrsne	r6, r2, r3, lsl #1
    a1b0:	1affff48 	bne	9ed8 <__aeabi_dmul+0x1ac>
    a1b4:	e1904081 	orrs	r4, r0, r1, lsl #1
    a1b8:	1affff74 	bne	9f90 <__aeabi_dmul+0x264>
    a1bc:	e1925083 	orrs	r5, r2, r3, lsl #1
    a1c0:	1affff5e 	bne	9f40 <__aeabi_dmul+0x214>
    a1c4:	eaffff78 	b	9fac <__aeabi_dmul+0x280>

0000a1c8 <__gedf2>:
    a1c8:	e3e0c000 	mvn	ip, #0
    a1cc:	ea000002 	b	a1dc <__cmpdf2+0x4>

0000a1d0 <__ledf2>:
    a1d0:	e3a0c001 	mov	ip, #1
    a1d4:	ea000000 	b	a1dc <__cmpdf2+0x4>

0000a1d8 <__cmpdf2>:
    a1d8:	e3a0c001 	mov	ip, #1
    a1dc:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
    a1e0:	e1a0c081 	lsl	ip, r1, #1
    a1e4:	e1f0cacc 	mvns	ip, ip, asr #21
    a1e8:	e1a0c083 	lsl	ip, r3, #1
    a1ec:	11f0cacc 	mvnsne	ip, ip, asr #21
    a1f0:	0a00000e 	beq	a230 <__cmpdf2+0x58>
    a1f4:	e28dd004 	add	sp, sp, #4
    a1f8:	e190c081 	orrs	ip, r0, r1, lsl #1
    a1fc:	0192c083 	orrseq	ip, r2, r3, lsl #1
    a200:	11310003 	teqne	r1, r3
    a204:	01300002 	teqeq	r0, r2
    a208:	03a00000 	moveq	r0, #0
    a20c:	012fff1e 	bxeq	lr
    a210:	e3700000 	cmn	r0, #0
    a214:	e1310003 	teq	r1, r3
    a218:	51510003 	cmppl	r1, r3
    a21c:	01500002 	cmpeq	r0, r2
    a220:	21a00fc3 	asrcs	r0, r3, #31
    a224:	31e00fc3 	mvncc	r0, r3, asr #31
    a228:	e3800001 	orr	r0, r0, #1
    a22c:	e12fff1e 	bx	lr
    a230:	e1a0c081 	lsl	ip, r1, #1
    a234:	e1f0cacc 	mvns	ip, ip, asr #21
    a238:	1a000001 	bne	a244 <__cmpdf2+0x6c>
    a23c:	e190c601 	orrs	ip, r0, r1, lsl #12
    a240:	1a000004 	bne	a258 <__cmpdf2+0x80>
    a244:	e1a0c083 	lsl	ip, r3, #1
    a248:	e1f0cacc 	mvns	ip, ip, asr #21
    a24c:	1affffe8 	bne	a1f4 <__cmpdf2+0x1c>
    a250:	e192c603 	orrs	ip, r2, r3, lsl #12
    a254:	0affffe6 	beq	a1f4 <__cmpdf2+0x1c>
    a258:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
    a25c:	e12fff1e 	bx	lr

0000a260 <__aeabi_cdrcmple>:
    a260:	e1a0c000 	mov	ip, r0
    a264:	e1a00002 	mov	r0, r2
    a268:	e1a0200c 	mov	r2, ip
    a26c:	e1a0c001 	mov	ip, r1
    a270:	e1a01003 	mov	r1, r3
    a274:	e1a0300c 	mov	r3, ip
    a278:	eaffffff 	b	a27c <__aeabi_cdcmpeq>

0000a27c <__aeabi_cdcmpeq>:
    a27c:	e92d4001 	push	{r0, lr}
    a280:	ebffffd4 	bl	a1d8 <__cmpdf2>
    a284:	e3500000 	cmp	r0, #0
    a288:	43700000 	cmnmi	r0, #0
    a28c:	e8bd4001 	pop	{r0, lr}
    a290:	e12fff1e 	bx	lr

0000a294 <__aeabi_dcmpeq>:
    a294:	e52de008 	str	lr, [sp, #-8]!
    a298:	ebfffff7 	bl	a27c <__aeabi_cdcmpeq>
    a29c:	03a00001 	moveq	r0, #1
    a2a0:	13a00000 	movne	r0, #0
    a2a4:	e49de008 	ldr	lr, [sp], #8
    a2a8:	e12fff1e 	bx	lr

0000a2ac <__aeabi_dcmplt>:
    a2ac:	e52de008 	str	lr, [sp, #-8]!
    a2b0:	ebfffff1 	bl	a27c <__aeabi_cdcmpeq>
    a2b4:	33a00001 	movcc	r0, #1
    a2b8:	23a00000 	movcs	r0, #0
    a2bc:	e49de008 	ldr	lr, [sp], #8
    a2c0:	e12fff1e 	bx	lr

0000a2c4 <__aeabi_dcmple>:
    a2c4:	e52de008 	str	lr, [sp, #-8]!
    a2c8:	ebffffeb 	bl	a27c <__aeabi_cdcmpeq>
    a2cc:	93a00001 	movls	r0, #1
    a2d0:	83a00000 	movhi	r0, #0
    a2d4:	e49de008 	ldr	lr, [sp], #8
    a2d8:	e12fff1e 	bx	lr

0000a2dc <__aeabi_dcmpge>:
    a2dc:	e52de008 	str	lr, [sp, #-8]!
    a2e0:	ebffffde 	bl	a260 <__aeabi_cdrcmple>
    a2e4:	93a00001 	movls	r0, #1
    a2e8:	83a00000 	movhi	r0, #0
    a2ec:	e49de008 	ldr	lr, [sp], #8
    a2f0:	e12fff1e 	bx	lr

0000a2f4 <__aeabi_dcmpgt>:
    a2f4:	e52de008 	str	lr, [sp, #-8]!
    a2f8:	ebffffd8 	bl	a260 <__aeabi_cdrcmple>
    a2fc:	33a00001 	movcc	r0, #1
    a300:	23a00000 	movcs	r0, #0
    a304:	e49de008 	ldr	lr, [sp], #8
    a308:	e12fff1e 	bx	lr

0000a30c <__aeabi_d2uiz>:
    a30c:	e1b02081 	lsls	r2, r1, #1
    a310:	2a00000a 	bcs	a340 <__aeabi_d2uiz+0x34>
    a314:	e2922602 	adds	r2, r2, #2097152	; 0x200000
    a318:	2a00000a 	bcs	a348 <__aeabi_d2uiz+0x3c>
    a31c:	5a000007 	bpl	a340 <__aeabi_d2uiz+0x34>
    a320:	e3e03e3e 	mvn	r3, #992	; 0x3e0
    a324:	e0532ac2 	subs	r2, r3, r2, asr #21
    a328:	4a000008 	bmi	a350 <__aeabi_d2uiz+0x44>
    a32c:	e1a03581 	lsl	r3, r1, #11
    a330:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    a334:	e1833aa0 	orr	r3, r3, r0, lsr #21
    a338:	e1a00233 	lsr	r0, r3, r2
    a33c:	e12fff1e 	bx	lr
    a340:	e3a00000 	mov	r0, #0
    a344:	e12fff1e 	bx	lr
    a348:	e1900601 	orrs	r0, r0, r1, lsl #12
    a34c:	1a000001 	bne	a358 <__aeabi_d2uiz+0x4c>
    a350:	e3e00000 	mvn	r0, #0
    a354:	e12fff1e 	bx	lr
    a358:	e3a00000 	mov	r0, #0
    a35c:	e12fff1e 	bx	lr

0000a360 <__aeabi_frsub>:
    a360:	e2200102 	eor	r0, r0, #-2147483648	; 0x80000000
    a364:	ea000000 	b	a36c <__addsf3>

0000a368 <__aeabi_fsub>:
    a368:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000

0000a36c <__addsf3>:
    a36c:	e1b02080 	lsls	r2, r0, #1
    a370:	11b03081 	lslsne	r3, r1, #1
    a374:	11320003 	teqne	r2, r3
    a378:	11f0cc42 	mvnsne	ip, r2, asr #24
    a37c:	11f0cc43 	mvnsne	ip, r3, asr #24
    a380:	0a000047 	beq	a4a4 <__addsf3+0x138>
    a384:	e1a02c22 	lsr	r2, r2, #24
    a388:	e0723c23 	rsbs	r3, r2, r3, lsr #24
    a38c:	c0822003 	addgt	r2, r2, r3
    a390:	c0201001 	eorgt	r1, r0, r1
    a394:	c0210000 	eorgt	r0, r1, r0
    a398:	c0201001 	eorgt	r1, r0, r1
    a39c:	b2633000 	rsblt	r3, r3, #0
    a3a0:	e3530019 	cmp	r3, #25
    a3a4:	812fff1e 	bxhi	lr
    a3a8:	e3100102 	tst	r0, #-2147483648	; 0x80000000
    a3ac:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    a3b0:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
    a3b4:	12600000 	rsbne	r0, r0, #0
    a3b8:	e3110102 	tst	r1, #-2147483648	; 0x80000000
    a3bc:	e3811502 	orr	r1, r1, #8388608	; 0x800000
    a3c0:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
    a3c4:	12611000 	rsbne	r1, r1, #0
    a3c8:	e1320003 	teq	r2, r3
    a3cc:	0a00002e 	beq	a48c <__addsf3+0x120>
    a3d0:	e2422001 	sub	r2, r2, #1
    a3d4:	e0900351 	adds	r0, r0, r1, asr r3
    a3d8:	e2633020 	rsb	r3, r3, #32
    a3dc:	e1a01311 	lsl	r1, r1, r3
    a3e0:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
    a3e4:	5a000001 	bpl	a3f0 <__addsf3+0x84>
    a3e8:	e2711000 	rsbs	r1, r1, #0
    a3ec:	e2e00000 	rsc	r0, r0, #0
    a3f0:	e3500502 	cmp	r0, #8388608	; 0x800000
    a3f4:	3a00000b 	bcc	a428 <__addsf3+0xbc>
    a3f8:	e3500401 	cmp	r0, #16777216	; 0x1000000
    a3fc:	3a000004 	bcc	a414 <__addsf3+0xa8>
    a400:	e1b000a0 	lsrs	r0, r0, #1
    a404:	e1a01061 	rrx	r1, r1
    a408:	e2822001 	add	r2, r2, #1
    a40c:	e35200fe 	cmp	r2, #254	; 0xfe
    a410:	2a000038 	bcs	a4f8 <__addsf3+0x18c>
    a414:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    a418:	e0a00b82 	adc	r0, r0, r2, lsl #23
    a41c:	03c00001 	biceq	r0, r0, #1
    a420:	e1800003 	orr	r0, r0, r3
    a424:	e12fff1e 	bx	lr
    a428:	e1b01081 	lsls	r1, r1, #1
    a42c:	e0a00000 	adc	r0, r0, r0
    a430:	e2522001 	subs	r2, r2, #1
    a434:	23500502 	cmpcs	r0, #8388608	; 0x800000
    a438:	2afffff5 	bcs	a414 <__addsf3+0xa8>
    a43c:	e1b0c620 	lsrs	ip, r0, #12
    a440:	01a00600 	lsleq	r0, r0, #12
    a444:	0242200c 	subeq	r2, r2, #12
    a448:	e31008ff 	tst	r0, #16711680	; 0xff0000
    a44c:	01a00400 	lsleq	r0, r0, #8
    a450:	02422008 	subeq	r2, r2, #8
    a454:	e310060f 	tst	r0, #15728640	; 0xf00000
    a458:	01a00200 	lsleq	r0, r0, #4
    a45c:	02422004 	subeq	r2, r2, #4
    a460:	e3100503 	tst	r0, #12582912	; 0xc00000
    a464:	01a00100 	lsleq	r0, r0, #2
    a468:	02422002 	subeq	r2, r2, #2
    a46c:	e3500502 	cmp	r0, #8388608	; 0x800000
    a470:	31a00080 	lslcc	r0, r0, #1
    a474:	e2d22000 	sbcs	r2, r2, #0
    a478:	a0800b82 	addge	r0, r0, r2, lsl #23
    a47c:	b2622000 	rsblt	r2, r2, #0
    a480:	a1800003 	orrge	r0, r0, r3
    a484:	b1830230 	orrlt	r0, r3, r0, lsr r2
    a488:	e12fff1e 	bx	lr
    a48c:	e3320000 	teq	r2, #0
    a490:	e2211502 	eor	r1, r1, #8388608	; 0x800000
    a494:	02200502 	eoreq	r0, r0, #8388608	; 0x800000
    a498:	02822001 	addeq	r2, r2, #1
    a49c:	12433001 	subne	r3, r3, #1
    a4a0:	eaffffca 	b	a3d0 <__addsf3+0x64>
    a4a4:	e1a03081 	lsl	r3, r1, #1
    a4a8:	e1f0cc42 	mvns	ip, r2, asr #24
    a4ac:	11f0cc43 	mvnsne	ip, r3, asr #24
    a4b0:	0a000013 	beq	a504 <__addsf3+0x198>
    a4b4:	e1320003 	teq	r2, r3
    a4b8:	0a000002 	beq	a4c8 <__addsf3+0x15c>
    a4bc:	e3320000 	teq	r2, #0
    a4c0:	01a00001 	moveq	r0, r1
    a4c4:	e12fff1e 	bx	lr
    a4c8:	e1300001 	teq	r0, r1
    a4cc:	13a00000 	movne	r0, #0
    a4d0:	112fff1e 	bxne	lr
    a4d4:	e31204ff 	tst	r2, #-16777216	; 0xff000000
    a4d8:	1a000002 	bne	a4e8 <__addsf3+0x17c>
    a4dc:	e1b00080 	lsls	r0, r0, #1
    a4e0:	23800102 	orrcs	r0, r0, #-2147483648	; 0x80000000
    a4e4:	e12fff1e 	bx	lr
    a4e8:	e2922402 	adds	r2, r2, #33554432	; 0x2000000
    a4ec:	32800502 	addcc	r0, r0, #8388608	; 0x800000
    a4f0:	312fff1e 	bxcc	lr
    a4f4:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
    a4f8:	e383047f 	orr	r0, r3, #2130706432	; 0x7f000000
    a4fc:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    a500:	e12fff1e 	bx	lr
    a504:	e1f02c42 	mvns	r2, r2, asr #24
    a508:	11a00001 	movne	r0, r1
    a50c:	01f03c43 	mvnseq	r3, r3, asr #24
    a510:	11a01000 	movne	r1, r0
    a514:	e1b02480 	lsls	r2, r0, #9
    a518:	01b03481 	lslseq	r3, r1, #9
    a51c:	01300001 	teqeq	r0, r1
    a520:	13800501 	orrne	r0, r0, #4194304	; 0x400000
    a524:	e12fff1e 	bx	lr

0000a528 <__aeabi_ui2f>:
    a528:	e3a03000 	mov	r3, #0
    a52c:	ea000001 	b	a538 <__aeabi_i2f+0x8>

0000a530 <__aeabi_i2f>:
    a530:	e2103102 	ands	r3, r0, #-2147483648	; 0x80000000
    a534:	42600000 	rsbmi	r0, r0, #0
    a538:	e1b0c000 	movs	ip, r0
    a53c:	012fff1e 	bxeq	lr
    a540:	e383344b 	orr	r3, r3, #1258291200	; 0x4b000000
    a544:	e1a01000 	mov	r1, r0
    a548:	e3a00000 	mov	r0, #0
    a54c:	ea00000f 	b	a590 <__aeabi_l2f+0x30>

0000a550 <__aeabi_ul2f>:
    a550:	e1902001 	orrs	r2, r0, r1
    a554:	012fff1e 	bxeq	lr
    a558:	e3a03000 	mov	r3, #0
    a55c:	ea000005 	b	a578 <__aeabi_l2f+0x18>

0000a560 <__aeabi_l2f>:
    a560:	e1902001 	orrs	r2, r0, r1
    a564:	012fff1e 	bxeq	lr
    a568:	e2113102 	ands	r3, r1, #-2147483648	; 0x80000000
    a56c:	5a000001 	bpl	a578 <__aeabi_l2f+0x18>
    a570:	e2700000 	rsbs	r0, r0, #0
    a574:	e2e11000 	rsc	r1, r1, #0
    a578:	e1b0c001 	movs	ip, r1
    a57c:	01a0c000 	moveq	ip, r0
    a580:	01a01000 	moveq	r1, r0
    a584:	03a00000 	moveq	r0, #0
    a588:	e383345b 	orr	r3, r3, #1526726656	; 0x5b000000
    a58c:	02433201 	subeq	r3, r3, #268435456	; 0x10000000
    a590:	e2433502 	sub	r3, r3, #8388608	; 0x800000
    a594:	e3a02017 	mov	r2, #23
    a598:	e35c0801 	cmp	ip, #65536	; 0x10000
    a59c:	21a0c82c 	lsrcs	ip, ip, #16
    a5a0:	22422010 	subcs	r2, r2, #16
    a5a4:	e35c0c01 	cmp	ip, #256	; 0x100
    a5a8:	21a0c42c 	lsrcs	ip, ip, #8
    a5ac:	22422008 	subcs	r2, r2, #8
    a5b0:	e35c0010 	cmp	ip, #16
    a5b4:	21a0c22c 	lsrcs	ip, ip, #4
    a5b8:	22422004 	subcs	r2, r2, #4
    a5bc:	e35c0004 	cmp	ip, #4
    a5c0:	22422002 	subcs	r2, r2, #2
    a5c4:	304220ac 	subcc	r2, r2, ip, lsr #1
    a5c8:	e05221ac 	subs	r2, r2, ip, lsr #3
    a5cc:	e0433b82 	sub	r3, r3, r2, lsl #23
    a5d0:	ba000006 	blt	a5f0 <__aeabi_l2f+0x90>
    a5d4:	e0833211 	add	r3, r3, r1, lsl r2
    a5d8:	e1a0c210 	lsl	ip, r0, r2
    a5dc:	e2622020 	rsb	r2, r2, #32
    a5e0:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
    a5e4:	e0a30230 	adc	r0, r3, r0, lsr r2
    a5e8:	03c00001 	biceq	r0, r0, #1
    a5ec:	e12fff1e 	bx	lr
    a5f0:	e2822020 	add	r2, r2, #32
    a5f4:	e1a0c211 	lsl	ip, r1, r2
    a5f8:	e2622020 	rsb	r2, r2, #32
    a5fc:	e190008c 	orrs	r0, r0, ip, lsl #1
    a600:	e0a30231 	adc	r0, r3, r1, lsr r2
    a604:	01c00fac 	biceq	r0, r0, ip, lsr #31
    a608:	e12fff1e 	bx	lr

0000a60c <__aeabi_fmul>:
    a60c:	e3a0c0ff 	mov	ip, #255	; 0xff
    a610:	e01c2ba0 	ands	r2, ip, r0, lsr #23
    a614:	101c3ba1 	andsne	r3, ip, r1, lsr #23
    a618:	1132000c 	teqne	r2, ip
    a61c:	1133000c 	teqne	r3, ip
    a620:	0a00003e 	beq	a720 <__aeabi_fmul+0x114>
    a624:	e0822003 	add	r2, r2, r3
    a628:	e020c001 	eor	ip, r0, r1
    a62c:	e1b00480 	lsls	r0, r0, #9
    a630:	11b01481 	lslsne	r1, r1, #9
    a634:	0a000010 	beq	a67c <__aeabi_fmul+0x70>
    a638:	e3a03302 	mov	r3, #134217728	; 0x8000000
    a63c:	e18302a0 	orr	r0, r3, r0, lsr #5
    a640:	e18312a1 	orr	r1, r3, r1, lsr #5
    a644:	e0813190 	umull	r3, r1, r0, r1
    a648:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
    a64c:	e3510502 	cmp	r1, #8388608	; 0x800000
    a650:	31a01081 	lslcc	r1, r1, #1
    a654:	31811fa3 	orrcc	r1, r1, r3, lsr #31
    a658:	31a03083 	lslcc	r3, r3, #1
    a65c:	e1800001 	orr	r0, r0, r1
    a660:	e2c2207f 	sbc	r2, r2, #127	; 0x7f
    a664:	e35200fd 	cmp	r2, #253	; 0xfd
    a668:	8a00000f 	bhi	a6ac <__aeabi_fmul+0xa0>
    a66c:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
    a670:	e0a00b82 	adc	r0, r0, r2, lsl #23
    a674:	03c00001 	biceq	r0, r0, #1
    a678:	e12fff1e 	bx	lr
    a67c:	e3300000 	teq	r0, #0
    a680:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
    a684:	01a01481 	lsleq	r1, r1, #9
    a688:	e18c04a0 	orr	r0, ip, r0, lsr #9
    a68c:	e18004a1 	orr	r0, r0, r1, lsr #9
    a690:	e252207f 	subs	r2, r2, #127	; 0x7f
    a694:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
    a698:	c1800b82 	orrgt	r0, r0, r2, lsl #23
    a69c:	c12fff1e 	bxgt	lr
    a6a0:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    a6a4:	e3a03000 	mov	r3, #0
    a6a8:	e2522001 	subs	r2, r2, #1
    a6ac:	ca000035 	bgt	a788 <__aeabi_fmul+0x17c>
    a6b0:	e3720019 	cmn	r2, #25
    a6b4:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
    a6b8:	d12fff1e 	bxle	lr
    a6bc:	e2622000 	rsb	r2, r2, #0
    a6c0:	e1b01080 	lsls	r1, r0, #1
    a6c4:	e1a01231 	lsr	r1, r1, r2
    a6c8:	e2622020 	rsb	r2, r2, #32
    a6cc:	e1a0c210 	lsl	ip, r0, r2
    a6d0:	e1b00061 	rrxs	r0, r1
    a6d4:	e2a00000 	adc	r0, r0, #0
    a6d8:	e193308c 	orrs	r3, r3, ip, lsl #1
    a6dc:	01c00fac 	biceq	r0, r0, ip, lsr #31
    a6e0:	e12fff1e 	bx	lr
    a6e4:	e3320000 	teq	r2, #0
    a6e8:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
    a6ec:	01a00080 	lsleq	r0, r0, #1
    a6f0:	03100502 	tsteq	r0, #8388608	; 0x800000
    a6f4:	02422001 	subeq	r2, r2, #1
    a6f8:	0afffffb 	beq	a6ec <__aeabi_fmul+0xe0>
    a6fc:	e180000c 	orr	r0, r0, ip
    a700:	e3330000 	teq	r3, #0
    a704:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
    a708:	01a01081 	lsleq	r1, r1, #1
    a70c:	03110502 	tsteq	r1, #8388608	; 0x800000
    a710:	02433001 	subeq	r3, r3, #1
    a714:	0afffffb 	beq	a708 <__aeabi_fmul+0xfc>
    a718:	e181100c 	orr	r1, r1, ip
    a71c:	eaffffc0 	b	a624 <__aeabi_fmul+0x18>
    a720:	e00c3ba1 	and	r3, ip, r1, lsr #23
    a724:	e132000c 	teq	r2, ip
    a728:	1133000c 	teqne	r3, ip
    a72c:	0a000005 	beq	a748 <__aeabi_fmul+0x13c>
    a730:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
    a734:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
    a738:	1affffe9 	bne	a6e4 <__aeabi_fmul+0xd8>
    a73c:	e0200001 	eor	r0, r0, r1
    a740:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    a744:	e12fff1e 	bx	lr
    a748:	e3300000 	teq	r0, #0
    a74c:	13300102 	teqne	r0, #-2147483648	; 0x80000000
    a750:	01a00001 	moveq	r0, r1
    a754:	13310000 	teqne	r1, #0
    a758:	13310102 	teqne	r1, #-2147483648	; 0x80000000
    a75c:	0a00000d 	beq	a798 <__aeabi_fmul+0x18c>
    a760:	e132000c 	teq	r2, ip
    a764:	1a000001 	bne	a770 <__aeabi_fmul+0x164>
    a768:	e1b02480 	lsls	r2, r0, #9
    a76c:	1a000009 	bne	a798 <__aeabi_fmul+0x18c>
    a770:	e133000c 	teq	r3, ip
    a774:	1a000002 	bne	a784 <__aeabi_fmul+0x178>
    a778:	e1b03481 	lsls	r3, r1, #9
    a77c:	11a00001 	movne	r0, r1
    a780:	1a000004 	bne	a798 <__aeabi_fmul+0x18c>
    a784:	e0200001 	eor	r0, r0, r1
    a788:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    a78c:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    a790:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    a794:	e12fff1e 	bx	lr
    a798:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    a79c:	e3800503 	orr	r0, r0, #12582912	; 0xc00000
    a7a0:	e12fff1e 	bx	lr

0000a7a4 <__aeabi_fdiv>:
    a7a4:	e3a0c0ff 	mov	ip, #255	; 0xff
    a7a8:	e01c2ba0 	ands	r2, ip, r0, lsr #23
    a7ac:	101c3ba1 	andsne	r3, ip, r1, lsr #23
    a7b0:	1132000c 	teqne	r2, ip
    a7b4:	1133000c 	teqne	r3, ip
    a7b8:	0a00003a 	beq	a8a8 <__aeabi_fdiv+0x104>
    a7bc:	e0422003 	sub	r2, r2, r3
    a7c0:	e020c001 	eor	ip, r0, r1
    a7c4:	e1b01481 	lsls	r1, r1, #9
    a7c8:	e1a00480 	lsl	r0, r0, #9
    a7cc:	0a00001c 	beq	a844 <__aeabi_fdiv+0xa0>
    a7d0:	e3a03201 	mov	r3, #268435456	; 0x10000000
    a7d4:	e1831221 	orr	r1, r3, r1, lsr #4
    a7d8:	e1833220 	orr	r3, r3, r0, lsr #4
    a7dc:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
    a7e0:	e1530001 	cmp	r3, r1
    a7e4:	31a03083 	lslcc	r3, r3, #1
    a7e8:	e2a2207d 	adc	r2, r2, #125	; 0x7d
    a7ec:	e3a0c502 	mov	ip, #8388608	; 0x800000
    a7f0:	e1530001 	cmp	r3, r1
    a7f4:	20433001 	subcs	r3, r3, r1
    a7f8:	2180000c 	orrcs	r0, r0, ip
    a7fc:	e15300a1 	cmp	r3, r1, lsr #1
    a800:	204330a1 	subcs	r3, r3, r1, lsr #1
    a804:	218000ac 	orrcs	r0, r0, ip, lsr #1
    a808:	e1530121 	cmp	r3, r1, lsr #2
    a80c:	20433121 	subcs	r3, r3, r1, lsr #2
    a810:	2180012c 	orrcs	r0, r0, ip, lsr #2
    a814:	e15301a1 	cmp	r3, r1, lsr #3
    a818:	204331a1 	subcs	r3, r3, r1, lsr #3
    a81c:	218001ac 	orrcs	r0, r0, ip, lsr #3
    a820:	e1b03203 	lsls	r3, r3, #4
    a824:	11b0c22c 	lsrsne	ip, ip, #4
    a828:	1afffff0 	bne	a7f0 <__aeabi_fdiv+0x4c>
    a82c:	e35200fd 	cmp	r2, #253	; 0xfd
    a830:	8affff9d 	bhi	a6ac <__aeabi_fmul+0xa0>
    a834:	e1530001 	cmp	r3, r1
    a838:	e0a00b82 	adc	r0, r0, r2, lsl #23
    a83c:	03c00001 	biceq	r0, r0, #1
    a840:	e12fff1e 	bx	lr
    a844:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
    a848:	e18c04a0 	orr	r0, ip, r0, lsr #9
    a84c:	e292207f 	adds	r2, r2, #127	; 0x7f
    a850:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
    a854:	c1800b82 	orrgt	r0, r0, r2, lsl #23
    a858:	c12fff1e 	bxgt	lr
    a85c:	e3800502 	orr	r0, r0, #8388608	; 0x800000
    a860:	e3a03000 	mov	r3, #0
    a864:	e2522001 	subs	r2, r2, #1
    a868:	eaffff8f 	b	a6ac <__aeabi_fmul+0xa0>
    a86c:	e3320000 	teq	r2, #0
    a870:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
    a874:	01a00080 	lsleq	r0, r0, #1
    a878:	03100502 	tsteq	r0, #8388608	; 0x800000
    a87c:	02422001 	subeq	r2, r2, #1
    a880:	0afffffb 	beq	a874 <__aeabi_fdiv+0xd0>
    a884:	e180000c 	orr	r0, r0, ip
    a888:	e3330000 	teq	r3, #0
    a88c:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
    a890:	01a01081 	lsleq	r1, r1, #1
    a894:	03110502 	tsteq	r1, #8388608	; 0x800000
    a898:	02433001 	subeq	r3, r3, #1
    a89c:	0afffffb 	beq	a890 <__aeabi_fdiv+0xec>
    a8a0:	e181100c 	orr	r1, r1, ip
    a8a4:	eaffffc4 	b	a7bc <__aeabi_fdiv+0x18>
    a8a8:	e00c3ba1 	and	r3, ip, r1, lsr #23
    a8ac:	e132000c 	teq	r2, ip
    a8b0:	1a000005 	bne	a8cc <__aeabi_fdiv+0x128>
    a8b4:	e1b02480 	lsls	r2, r0, #9
    a8b8:	1affffb6 	bne	a798 <__aeabi_fmul+0x18c>
    a8bc:	e133000c 	teq	r3, ip
    a8c0:	1affffaf 	bne	a784 <__aeabi_fmul+0x178>
    a8c4:	e1a00001 	mov	r0, r1
    a8c8:	eaffffb2 	b	a798 <__aeabi_fmul+0x18c>
    a8cc:	e133000c 	teq	r3, ip
    a8d0:	1a000003 	bne	a8e4 <__aeabi_fdiv+0x140>
    a8d4:	e1b03481 	lsls	r3, r1, #9
    a8d8:	0affff97 	beq	a73c <__aeabi_fmul+0x130>
    a8dc:	e1a00001 	mov	r0, r1
    a8e0:	eaffffac 	b	a798 <__aeabi_fmul+0x18c>
    a8e4:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
    a8e8:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
    a8ec:	1affffde 	bne	a86c <__aeabi_fdiv+0xc8>
    a8f0:	e3d02102 	bics	r2, r0, #-2147483648	; 0x80000000
    a8f4:	1affffa2 	bne	a784 <__aeabi_fmul+0x178>
    a8f8:	e3d13102 	bics	r3, r1, #-2147483648	; 0x80000000
    a8fc:	1affff8e 	bne	a73c <__aeabi_fmul+0x130>
    a900:	eaffffa4 	b	a798 <__aeabi_fmul+0x18c>

0000a904 <__aeabi_f2iz>:
    a904:	e1a02080 	lsl	r2, r0, #1
    a908:	e352047f 	cmp	r2, #2130706432	; 0x7f000000
    a90c:	3a000008 	bcc	a934 <__aeabi_f2iz+0x30>
    a910:	e3a0309e 	mov	r3, #158	; 0x9e
    a914:	e0532c22 	subs	r2, r3, r2, lsr #24
    a918:	9a000007 	bls	a93c <__aeabi_f2iz+0x38>
    a91c:	e1a03400 	lsl	r3, r0, #8
    a920:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    a924:	e3100102 	tst	r0, #-2147483648	; 0x80000000
    a928:	e1a00233 	lsr	r0, r3, r2
    a92c:	12600000 	rsbne	r0, r0, #0
    a930:	e12fff1e 	bx	lr
    a934:	e3a00000 	mov	r0, #0
    a938:	e12fff1e 	bx	lr
    a93c:	e3720061 	cmn	r2, #97	; 0x61
    a940:	1a000001 	bne	a94c <__aeabi_f2iz+0x48>
    a944:	e1b02480 	lsls	r2, r0, #9
    a948:	1a000002 	bne	a958 <__aeabi_f2iz+0x54>
    a94c:	e2100102 	ands	r0, r0, #-2147483648	; 0x80000000
    a950:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
    a954:	e12fff1e 	bx	lr
    a958:	e3a00000 	mov	r0, #0
    a95c:	e12fff1e 	bx	lr
