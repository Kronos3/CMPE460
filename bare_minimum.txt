
../../cmake-build-bcm2835/top/bcm2835/bare_minimum:     file format elf32-littlearm


Disassembly of section .init:

00008000 <_start>:
;;
_start:
    ;@ All the following instruction should be read as:
    ;@ Load the address at symbol into the program counter.

    ldr    pc,reset_handler        ;@     Processor Reset handler         -- we will have to force this on the raspi!
    8000:	e59ff018 	ldr	pc, [pc, #24]	; 8020 <reset_handler>
    ;@ Because this is the first instruction executed, of cause it causes an immediate branch into reset!

    ldr pc,undefined_handler    ;@     Undefined instruction handler     -- processors that don't have thumb can emulate thumb!
    8004:	e59ff018 	ldr	pc, [pc, #24]	; 8024 <undefined_handler>
    ldr pc,swi_handler            ;@     Software interrupt / TRAP (SVC) -- system SVC handler for switching to kernel mode.
    8008:	e59ff018 	ldr	pc, [pc, #24]	; 8028 <swi_handler>
    ldr pc,prefetch_handler        ;@     Prefetch/abort handler.
    800c:	e59ff018 	ldr	pc, [pc, #24]	; 802c <prefetch_handler>
    ldr pc,data_handler            ;@     Data abort handler/
    8010:	e59ff018 	ldr	pc, [pc, #24]	; 8030 <data_handler>
    ldr pc,unused_handler        ;@     -- Historical from 26-bit addressing ARMs -- was invalid address handler.
    8014:	e59ff018 	ldr	pc, [pc, #24]	; 8034 <unused_handler>
    ldr pc,irq_handler            ;@     IRQ handler
    8018:	e59ff018 	ldr	pc, [pc, #24]	; 8038 <irq_handler>
    ldr pc,fiq_handler            ;@     Fast interrupt handler.
    801c:	e59ff018 	ldr	pc, [pc, #24]	; 803c <fiq_handler>

00008020 <reset_handler>:
    8020:	00008040 	.word	0x00008040

00008024 <undefined_handler>:
    8024:	0001008c 	.word	0x0001008c

00008028 <swi_handler>:
    8028:	000101a4 	.word	0x000101a4

0000802c <prefetch_handler>:
    802c:	00010090 	.word	0x00010090

00008030 <data_handler>:
    8030:	00010094 	.word	0x00010094

00008034 <unused_handler>:
    8034:	00010098 	.word	0x00010098

00008038 <irq_handler>:
    8038:	000100a0 	.word	0x000100a0

0000803c <fiq_handler>:
    803c:	000101a8 	.word	0x000101a8

00008040 <reset>:
    .ltorg

reset:
    ;@    In the reset handler, we need to copy our interrupt vector table to 0x0000, its currently at 0x8000

    mov r0,#0x8000                                ;@ Store the source pointer
    8040:	e3a00902 	mov	r0, #32768	; 0x8000
    mov r1,#0x0000                                ;@ Store the destination pointer.
    8044:	e3a01000 	mov	r1, #0

    ;@    Here we copy the branching instructions
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}            ;@ Load multiple values from indexed address.         ; Auto-increment R0
    8048:	e8b003fc 	ldm	r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}            ;@ Store multiple values from the indexed address.    ; Auto-increment R1
    804c:	e8a103fc 	stmia	r1!, {r2, r3, r4, r5, r6, r7, r8, r9}

    ;@    So the branches get the correct address we also need to copy our vector table!
    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}            ;@ Load from 4*n of regs (8) as R0 is now incremented.
    8050:	e8b003fc 	ldm	r0!, {r2, r3, r4, r5, r6, r7, r8, r9}
    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}            ;@ Store this extra set of data.
    8054:	e8a103fc 	stmia	r1!, {r2, r3, r4, r5, r6, r7, r8, r9}


    ;@    Set up the various STACK pointers for different CPU modes
    ;@ (PSR_IRQ_MODE|PSR_FIQ_DIS|PSR_IRQ_DIS)
    mov r0,#0xD2
    8058:	e3a000d2 	mov	r0, #210	; 0xd2
    msr cpsr_c,r0
    805c:	e121f000 	msr	CPSR_c, r0
    mov sp,#0x8000
    8060:	e3a0d902 	mov	sp, #32768	; 0x8000

    ;@ (PSR_FIQ_MODE|PSR_FIQ_DIS|PSR_IRQ_DIS)
    mov r0,#0xD1
    8064:	e3a000d1 	mov	r0, #209	; 0xd1
    msr cpsr_c,r0
    8068:	e121f000 	msr	CPSR_c, r0
    mov sp,#0x4000
    806c:	e3a0d901 	mov	sp, #16384	; 0x4000

    ;@ (PSR_SVC_MODE|PSR_FIQ_DIS|PSR_IRQ_DIS)
    mov r0,#0xD3
    8070:	e3a000d3 	mov	r0, #211	; 0xd3
    msr cpsr_c,r0
    8074:	e121f000 	msr	CPSR_c, r0
    mov sp,#0x8000000
    8078:	e3a0d302 	mov	sp, #134217728	; 0x8000000

    ldr r0, =__bss_start
    807c:	e59f0018 	ldr	r0, [pc, #24]	; 809c <zero_loop+0x14>
    ldr r1, =__bss_end
    8080:	e59f1018 	ldr	r1, [pc, #24]	; 80a0 <zero_loop+0x18>

    mov r2, #0
    8084:	e3a02000 	mov	r2, #0

00008088 <zero_loop>:

zero_loop:
    cmp     r0,r1
    8088:	e1500001 	cmp	r0, r1
    it        lt
    strlt    r2,[r0], #4
    808c:	b4802004 	strlt	r2, [r0], #4
    blt        zero_loop
    8090:	bafffffc 	blt	8088 <zero_loop>
    ;@ Disable interrupts
    ;@ cpsid i


    ;@     mov    sp,#0x1000000
    bl main                                    ;@ We're ready?? Lets start main execution!
    8094:	eb0020a5 	bl	10330 <main>
    b hang
    8098:	ea001fff 	b	1009c <hang>
    ldr r0, =__bss_start
    809c:	00010400 	.word	0x00010400
    ldr r1, =__bss_end
    80a0:	0001052c 	.word	0x0001052c

Disassembly of section .text:

00010000 <nop_handler>:
#include <stdarg.h>
#include <fw.h>

I32 nop_handler(const char* fmt, ...)
{
   10000:	e92d000f 	push	{r0, r1, r2, r3}
    (void) nop_handler;
    (void) fmt;
    return 0;
}
   10004:	e3a00000 	mov	r0, #0
   10008:	e28dd010 	add	sp, sp, #16
   1000c:	e12fff1e 	bx	lr

00010010 <fw_assertion_failure>:
#endif

void fw_assertion_failure(const char* file, U32 line,
                          const char* expr_str,
                          U32 nargs, ...)
{
   10010:	e52d3004 	push	{r3}		; (str r3, [sp, #-4]!)
   10014:	e1a0c001 	mov	ip, r1
   10018:	e92d4080 	push	{r7, lr}
   1001c:	e1a0e000 	mov	lr, r0
   10020:	e24dd00c 	sub	sp, sp, #12
   10024:	e59d6014 	ldr	r6, [sp, #20]
   10028:	e1a03002 	mov	r3, r2
    // Mask all interrupts
    // Assertion reached, nothing else should run
    DISABLE_INTERRUPTS();

    uprintf("Assertion failed %s:%u : (%s)",
   1002c:	e1a0100e 	mov	r1, lr
   10030:	e1a0200c 	mov	r2, ip
   10034:	e59f0044 	ldr	r0, [pc, #68]	; 10080 <fw_assertion_failure+0x70>
   10038:	ebfffff0 	bl	10000 <nop_handler>
            file, line, expr_str);

    va_list args;
    va_start(args, nargs);
   1003c:	e28d4018 	add	r4, sp, #24
    for (U32 i = 0; i < nargs; i++)
   10040:	e3560000 	cmp	r6, #0
   10044:	13a05000 	movne	r5, #0
    {
        uprintf(", %d", va_arg(args, int));
   10048:	159f7034 	ldrne	r7, [pc, #52]	; 10084 <fw_assertion_failure+0x74>
    va_start(args, nargs);
   1004c:	e58d4004 	str	r4, [sp, #4]
    for (U32 i = 0; i < nargs; i++)
   10050:	0a000007 	beq	10074 <fw_assertion_failure+0x64>
        uprintf(", %d", va_arg(args, int));
   10054:	e2844004 	add	r4, r4, #4
   10058:	e1a00007 	mov	r0, r7
    for (U32 i = 0; i < nargs; i++)
   1005c:	e2855001 	add	r5, r5, #1
        uprintf(", %d", va_arg(args, int));
   10060:	e5141004 	ldr	r1, [r4, #-4]
   10064:	e58d4004 	str	r4, [sp, #4]
   10068:	ebffffe4 	bl	10000 <nop_handler>
    for (U32 i = 0; i < nargs; i++)
   1006c:	e1560005 	cmp	r6, r5
   10070:	1afffff7 	bne	10054 <fw_assertion_failure+0x44>
    }
    va_end(args);
    uprintf("\r\n");
   10074:	e59f000c 	ldr	r0, [pc, #12]	; 10088 <fw_assertion_failure+0x78>
   10078:	ebffffe0 	bl	10000 <nop_handler>

    // Hang Mr. CPU please
//    BREAKPOINT(); // break point if we are in a debugger
    while (1)
   1007c:	eafffffe 	b	1007c <fw_assertion_failure+0x6c>
   10080:	00010378 	.word	0x00010378
   10084:	0001039c 	.word	0x0001039c
   10088:	00010398 	.word	0x00010398

0001008c <undefined_instruction>:

    .section .text

undefined_instruction:
    b undefined_instruction
   1008c:	eafffffe 	b	1008c <undefined_instruction>

00010090 <prefetch_abort>:

prefetch_abort:
    b prefetch_abort
   10090:	eafffffe 	b	10090 <prefetch_abort>

00010094 <data_abort>:

data_abort:
    b data_abort
   10094:	eafffffe 	b	10094 <data_abort>

00010098 <unused>:

unused:
    b unused
   10098:	eafffffe 	b	10098 <unused>

0001009c <hang>:

hang:
    b hang
   1009c:	eafffffe 	b	1009c <hang>

000100a0 <Interrupt_IRQHandler>:
    }
}

void __attribute__((interrupt("IRQ")))
Interrupt_IRQHandler(void)
{
   100a0:	e24ee004 	sub	lr, lr, #4
   100a4:	e92d53ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, lr}
    register U32 ul_masked_status = INTCREGS->IRQ_Basic;
   100a8:	e59f30ec 	ldr	r3, [pc, #236]	; 1019c <Interrupt_IRQHandler+0xfc>
   100ac:	e5935000 	ldr	r5, [r3]

    // Bit 8 in IRQBasic indicates interrupts in Pending1 (interrupts 31-0):
    if (ul_masked_status & (1UL << 8))
   100b0:	e3150c01 	tst	r5, #256	; 0x100
   100b4:	1a000027 	bne	10158 <Interrupt_IRQHandler+0xb8>
    {
        irq_handler_range(INTCREGS->Pending1 & enabled_interrupts[0], 0);
    }

    // Bit 9 in IRQBasic indicates interrupts in Pending2 (interrupts 63-32):
    if (ul_masked_status & (1UL << 9))
   100b8:	e3150c02 	tst	r5, #512	; 0x200
   100bc:	1a000013 	bne	10110 <Interrupt_IRQHandler+0x70>
    {
        irq_handler_range(INTCREGS->Pending2 & enabled_interrupts[1], 32);
    }

    // Bits 7 through 0 in IRQBasic represent interrupts 64-71:
    if (ul_masked_status & 0xFF)
   100c0:	e6ef3075 	uxtb	r3, r5
   100c4:	e3530000 	cmp	r3, #0
   100c8:	08fd93ff 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
    {
        irq_handler_range(ul_masked_status & 0xFF & enabled_interrupts[2], 64);
   100cc:	e59f60cc 	ldr	r6, [pc, #204]	; 101a0 <Interrupt_IRQHandler+0x100>
   100d0:	e5963008 	ldr	r3, [r6, #8]
   100d4:	e0054003 	and	r4, r5, r3
    while (pending)
   100d8:	e21440ff 	ands	r4, r4, #255	; 0xff
   100dc:	08fd93ff 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
        pending &= ~(1UL << bit);
   100e0:	e3a07001 	mov	r7, #1
        U32 bit = 31 - __builtin_clz(pending);
   100e4:	e16f5f14 	clz	r5, r4
        U32 irq = base + bit;
   100e8:	e265005f 	rsb	r0, r5, #95	; 0x5f
        if (vector_table[irq])
   100ec:	e0863100 	add	r3, r6, r0, lsl #2
   100f0:	e593300c 	ldr	r3, [r3, #12]
        U32 bit = 31 - __builtin_clz(pending);
   100f4:	e265501f 	rsb	r5, r5, #31
        if (vector_table[irq])
   100f8:	e3530000 	cmp	r3, #0
   100fc:	0a000000 	beq	10104 <Interrupt_IRQHandler+0x64>
            vector_table[irq](irq);
   10100:	e12fff33 	blx	r3
    while (pending)
   10104:	e1d44517 	bics	r4, r4, r7, lsl r5
   10108:	1afffff5 	bne	100e4 <Interrupt_IRQHandler+0x44>
   1010c:	e8fd93ff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, ip, pc}^
        irq_handler_range(INTCREGS->Pending2 & enabled_interrupts[1], 32);
   10110:	e59f3084 	ldr	r3, [pc, #132]	; 1019c <Interrupt_IRQHandler+0xfc>
   10114:	e59f6084 	ldr	r6, [pc, #132]	; 101a0 <Interrupt_IRQHandler+0x100>
   10118:	e5937008 	ldr	r7, [r3, #8]
   1011c:	e5963004 	ldr	r3, [r6, #4]
    while (pending)
   10120:	e0177003 	ands	r7, r7, r3
   10124:	0affffe5 	beq	100c0 <Interrupt_IRQHandler+0x20>
        pending &= ~(1UL << bit);
   10128:	e3a08001 	mov	r8, #1
        U32 bit = 31 - __builtin_clz(pending);
   1012c:	e16f4f17 	clz	r4, r7
        U32 irq = base + bit;
   10130:	e264003f 	rsb	r0, r4, #63	; 0x3f
        if (vector_table[irq])
   10134:	e0863100 	add	r3, r6, r0, lsl #2
   10138:	e593300c 	ldr	r3, [r3, #12]
        U32 bit = 31 - __builtin_clz(pending);
   1013c:	e264401f 	rsb	r4, r4, #31
        if (vector_table[irq])
   10140:	e3530000 	cmp	r3, #0
   10144:	0a000000 	beq	1014c <Interrupt_IRQHandler+0xac>
            vector_table[irq](irq);
   10148:	e12fff33 	blx	r3
    while (pending)
   1014c:	e1d77418 	bics	r7, r7, r8, lsl r4
   10150:	1afffff5 	bne	1012c <Interrupt_IRQHandler+0x8c>
   10154:	eaffffd9 	b	100c0 <Interrupt_IRQHandler+0x20>
        irq_handler_range(INTCREGS->Pending1 & enabled_interrupts[0], 0);
   10158:	e59f6040 	ldr	r6, [pc, #64]	; 101a0 <Interrupt_IRQHandler+0x100>
   1015c:	e5937004 	ldr	r7, [r3, #4]
   10160:	e5963000 	ldr	r3, [r6]
    while (pending)
   10164:	e0177003 	ands	r7, r7, r3
   10168:	0affffd2 	beq	100b8 <Interrupt_IRQHandler+0x18>
        pending &= ~(1UL << bit);
   1016c:	e3a08001 	mov	r8, #1
        U32 bit = 31 - __builtin_clz(pending);
   10170:	e16f4f17 	clz	r4, r7
   10174:	e264401f 	rsb	r4, r4, #31
        if (vector_table[irq])
   10178:	e0863104 	add	r3, r6, r4, lsl #2
   1017c:	e593300c 	ldr	r3, [r3, #12]
   10180:	e3530000 	cmp	r3, #0
   10184:	0a000001 	beq	10190 <Interrupt_IRQHandler+0xf0>
            vector_table[irq](irq);
   10188:	e1a00004 	mov	r0, r4
   1018c:	e12fff33 	blx	r3
    while (pending)
   10190:	e1d77418 	bics	r7, r7, r8, lsl r4
   10194:	1afffff5 	bne	10170 <Interrupt_IRQHandler+0xd0>
   10198:	eaffffc6 	b	100b8 <Interrupt_IRQHandler+0x18>
   1019c:	2000b200 	.word	0x2000b200
   101a0:	00010400 	.word	0x00010400

000101a4 <Yield_IRQHandler>:
}

void __attribute__((interrupt("SWI")))
Yield_IRQHandler(void)
{
}
   101a4:	e1b0f00e 	movs	pc, lr

000101a8 <Fast_IRQHandler>:

void __attribute__((interrupt("FIQ")))
Fast_IRQHandler(void)
{
}
   101a8:	e25ef004 	subs	pc, lr, #4

000101ac <bcm2835_interrupt_register>:

void bcm2835_interrupt_register(bcm2835_Interrupt irq,
                                bcm2835_InterruptHandler handler)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   101ac:	e3500047 	cmp	r0, #71	; 0x47
{
   101b0:	e1a0c000 	mov	ip, r0
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   101b4:	8a000003 	bhi	101c8 <bcm2835_interrupt_register+0x1c>
    vector_table[irq] = handler;
   101b8:	e59f3028 	ldr	r3, [pc, #40]	; 101e8 <bcm2835_interrupt_register+0x3c>
   101bc:	e0833100 	add	r3, r3, r0, lsl #2
   101c0:	e583100c 	str	r1, [r3, #12]
   101c4:	e12fff1e 	bx	lr
{
   101c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   101cc:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   101d0:	e3a03001 	mov	r3, #1
   101d4:	e3a01052 	mov	r1, #82	; 0x52
   101d8:	e59f200c 	ldr	r2, [pc, #12]	; 101ec <bcm2835_interrupt_register+0x40>
   101dc:	e59f000c 	ldr	r0, [pc, #12]	; 101f0 <bcm2835_interrupt_register+0x44>
   101e0:	e58dc000 	str	ip, [sp]
   101e4:	ebffff89 	bl	10010 <fw_assertion_failure>
   101e8:	00010400 	.word	0x00010400
   101ec:	000103a4 	.word	0x000103a4
   101f0:	000103c4 	.word	0x000103c4

000101f4 <bcm2835_interrupt_enable>:
}

void bcm2835_interrupt_enable(bcm2835_Interrupt irq)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   101f4:	e3500047 	cmp	r0, #71	; 0x47
{
   101f8:	e1a0c000 	mov	ip, r0
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   101fc:	8a000017 	bhi	10260 <bcm2835_interrupt_enable+0x6c>
    U32 mask = 1UL << (irq % 32);
   10200:	e3a03001 	mov	r3, #1
   10204:	e200201f 	and	r2, r0, #31

    if (irq <= 31)
   10208:	e350001f 	cmp	r0, #31
    U32 mask = 1UL << (irq % 32);
   1020c:	e1a03213 	lsl	r3, r3, r2
    if (irq <= 31)
   10210:	8a000006 	bhi	10230 <bcm2835_interrupt_enable+0x3c>
    {
        INTCREGS->Enable1 = mask;
   10214:	e59f2064 	ldr	r2, [pc, #100]	; 10280 <bcm2835_interrupt_enable+0x8c>
        enabled_interrupts[0] |= mask;
   10218:	e59f1064 	ldr	r1, [pc, #100]	; 10284 <bcm2835_interrupt_enable+0x90>
        INTCREGS->Enable1 = mask;
   1021c:	e5823010 	str	r3, [r2, #16]
        enabled_interrupts[0] |= mask;
   10220:	e5912000 	ldr	r2, [r1]
   10224:	e1823003 	orr	r3, r2, r3
   10228:	e5813000 	str	r3, [r1]
   1022c:	e12fff1e 	bx	lr
    }
    else if (irq <= 63)
    {
        INTCREGS->Enable2 = mask;
        enabled_interrupts[1] |= mask;
   10230:	e59f104c 	ldr	r1, [pc, #76]	; 10284 <bcm2835_interrupt_enable+0x90>
    else if (irq <= 63)
   10234:	e35c003f 	cmp	ip, #63	; 0x3f
        enabled_interrupts[1] |= mask;
   10238:	95912004 	ldrls	r2, [r1, #4]
    }
    else if (irq < BCM2835_INTC_TOTAL_IRQ)
    {
        INTCREGS->EnableBasic = mask;
        enabled_interrupts[2] |= mask;
   1023c:	85912008 	ldrhi	r2, [r1, #8]
        INTCREGS->Enable2 = mask;
   10240:	e59f0038 	ldr	r0, [pc, #56]	; 10280 <bcm2835_interrupt_enable+0x8c>
   10244:	95803014 	strls	r3, [r0, #20]
        INTCREGS->EnableBasic = mask;
   10248:	85803018 	strhi	r3, [r0, #24]
        enabled_interrupts[1] |= mask;
   1024c:	91823003 	orrls	r3, r2, r3
        enabled_interrupts[2] |= mask;
   10250:	81823003 	orrhi	r3, r2, r3
        enabled_interrupts[1] |= mask;
   10254:	95813004 	strls	r3, [r1, #4]
        enabled_interrupts[2] |= mask;
   10258:	85813008 	strhi	r3, [r1, #8]
   1025c:	e12fff1e 	bx	lr
{
   10260:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   10264:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   10268:	e3a03001 	mov	r3, #1
   1026c:	e3a01058 	mov	r1, #88	; 0x58
   10270:	e59f2010 	ldr	r2, [pc, #16]	; 10288 <bcm2835_interrupt_enable+0x94>
   10274:	e59f0010 	ldr	r0, [pc, #16]	; 1028c <bcm2835_interrupt_enable+0x98>
   10278:	e58dc000 	str	ip, [sp]
   1027c:	ebffff63 	bl	10010 <fw_assertion_failure>
   10280:	2000b200 	.word	0x2000b200
   10284:	00010400 	.word	0x00010400
   10288:	000103a4 	.word	0x000103a4
   1028c:	000103c4 	.word	0x000103c4

00010290 <bcm2835_interrupt_disable>:
    }
}

void bcm2835_interrupt_disable(bcm2835_Interrupt irq)
{
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   10290:	e3500047 	cmp	r0, #71	; 0x47
{
   10294:	e1a0c000 	mov	ip, r0
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   10298:	8a000018 	bhi	10300 <bcm2835_interrupt_disable+0x70>
    U32 mask = 1UL << (irq % 32);
   1029c:	e3a03001 	mov	r3, #1
   102a0:	e200201f 	and	r2, r0, #31
   102a4:	e1a03213 	lsl	r3, r3, r2

    if (irq <= 31)
   102a8:	e350001f 	cmp	r0, #31
    {
        INTCREGS->Disable1 = mask;
        enabled_interrupts[0] &= ~mask;
   102ac:	e1e02003 	mvn	r2, r3
    if (irq <= 31)
   102b0:	8a000006 	bhi	102d0 <bcm2835_interrupt_disable+0x40>
        INTCREGS->Disable1 = mask;
   102b4:	e59f0064 	ldr	r0, [pc, #100]	; 10320 <bcm2835_interrupt_disable+0x90>
        enabled_interrupts[0] &= ~mask;
   102b8:	e59f1064 	ldr	r1, [pc, #100]	; 10324 <bcm2835_interrupt_disable+0x94>
        INTCREGS->Disable1 = mask;
   102bc:	e580301c 	str	r3, [r0, #28]
        enabled_interrupts[0] &= ~mask;
   102c0:	e5913000 	ldr	r3, [r1]
   102c4:	e0033002 	and	r3, r3, r2
   102c8:	e5813000 	str	r3, [r1]
   102cc:	e12fff1e 	bx	lr
    }
    else if (irq <= 63)
    {
        INTCREGS->Disable2 = mask;
        enabled_interrupts[1] &= ~mask;
   102d0:	e59f004c 	ldr	r0, [pc, #76]	; 10324 <bcm2835_interrupt_disable+0x94>
    else if (irq <= 63)
   102d4:	e35c003f 	cmp	ip, #63	; 0x3f
        enabled_interrupts[1] &= ~mask;
   102d8:	95901004 	ldrls	r1, [r0, #4]
    }
    else if (irq < BCM2835_INTC_TOTAL_IRQ)
    {
        INTCREGS->DisableBasic = mask;
        enabled_interrupts[2] &= ~mask;
   102dc:	85901008 	ldrhi	r1, [r0, #8]
        INTCREGS->Disable2 = mask;
   102e0:	e59fc038 	ldr	ip, [pc, #56]	; 10320 <bcm2835_interrupt_disable+0x90>
   102e4:	958c3020 	strls	r3, [ip, #32]
        INTCREGS->DisableBasic = mask;
   102e8:	858c3024 	strhi	r3, [ip, #36]	; 0x24
        enabled_interrupts[1] &= ~mask;
   102ec:	90013002 	andls	r3, r1, r2
        enabled_interrupts[2] &= ~mask;
   102f0:	80013002 	andhi	r3, r1, r2
        enabled_interrupts[1] &= ~mask;
   102f4:	95803004 	strls	r3, [r0, #4]
        enabled_interrupts[2] &= ~mask;
   102f8:	85803008 	strhi	r3, [r0, #8]
   102fc:	e12fff1e 	bx	lr
{
   10300:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   10304:	e24dd00c 	sub	sp, sp, #12
    FW_ASSERT(irq < BCM2835_INTC_TOTAL_IRQ, irq);
   10308:	e3a03001 	mov	r3, #1
   1030c:	e3a0106e 	mov	r1, #110	; 0x6e
   10310:	e59f2010 	ldr	r2, [pc, #16]	; 10328 <bcm2835_interrupt_disable+0x98>
   10314:	e59f0010 	ldr	r0, [pc, #16]	; 1032c <bcm2835_interrupt_disable+0x9c>
   10318:	e58dc000 	str	ip, [sp]
   1031c:	ebffff3b 	bl	10010 <fw_assertion_failure>
   10320:	2000b200 	.word	0x2000b200
   10324:	00010400 	.word	0x00010400
   10328:	000103a4 	.word	0x000103a4
   1032c:	000103c4 	.word	0x000103c4

Disassembly of section .text.startup:

00010330 <main>:
    //ra|=1<<15;
    //PUT32(GPFSEL3,ra);

    while (1)
    {
        *GPSET1 = 1 << (47 - 32);
   10330:	e3a01902 	mov	r1, #32768	; 0x8000
    ra = *GPFSEL4;
   10334:	e59f2038 	ldr	r2, [pc, #56]	; 10374 <main+0x44>
   10338:	e5923010 	ldr	r3, [r2, #16]
    ra &= ~(7 << 21);
   1033c:	e3c3360e 	bic	r3, r3, #14680064	; 0xe00000
    ra |= 1 << 21;
   10340:	e3833602 	orr	r3, r3, #2097152	; 0x200000
    *GPFSEL4 = ra;
   10344:	e5823010 	str	r3, [r2, #16]
        //PUT32(GPCLR1,1<<(35-32));
        for (ra = 0; ra < 0x100000; ra++) dummy(ra);
   10348:	e3a03000 	mov	r3, #0
        *GPSET1 = 1 << (47 - 32);
   1034c:	e5821020 	str	r1, [r2, #32]
        for (ra = 0; ra < 0x100000; ra++) dummy(ra);
   10350:	e2833001 	add	r3, r3, #1
   10354:	e3530601 	cmp	r3, #1048576	; 0x100000
   10358:	1afffffc 	bne	10350 <main+0x20>
        *GPCLR1 = 1 << (47 - 32);
        //PUT32(GPSET1,1<<(35-32));
        for (ra = 0; ra < 0x100000; ra++) dummy(ra);
   1035c:	e3a03000 	mov	r3, #0
        *GPCLR1 = 1 << (47 - 32);
   10360:	e582102c 	str	r1, [r2, #44]	; 0x2c
        for (ra = 0; ra < 0x100000; ra++) dummy(ra);
   10364:	e2833001 	add	r3, r3, #1
   10368:	e3530601 	cmp	r3, #1048576	; 0x100000
   1036c:	1afffffc 	bne	10364 <main+0x34>
   10370:	eafffff4 	b	10348 <main+0x18>
   10374:	20200000 	.word	0x20200000
